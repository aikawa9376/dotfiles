# shougo---------------------------------

[[plugins]]
repo = 'neoclide/coc.nvim'
on_event = 'VimEnter'
depends = ['coc-neoinclude', 'neosnippet', 'coc-neco', 'coc-zsh']
marge = 0
build = './install.sh nightly'
hook_add = '''
" don't give |ins-completion-menu| messages.
set shortmess+=c
" always show signcolumns
set signcolumn=yes

let g:coc_status_error_sign   = "\uf057 :"
let g:coc_status_warning_sign = "\uf071 :"

let g:coc_snippet_next = '<C-Space>'

" Use tab for trigger completion with characters ahead and navigate.
" Use command ':verbose imap <tab>' to make sure tab is not mapped by other plugin.
imap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
imap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

imap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() : "\<CR>"
imap <silent><expr> <C-x><C-x> coc#refresh()

" Use `[a` and `]a` for navigate diagnostics
nmap <silent> [a <Plug>(coc-diagnostic-prev)
nmap <silent> ]a <Plug>(coc-diagnostic-next)

" Remap keys for gotos
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gr <Plug>(coc-references)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)

" Use K for show documentation in preview window
nnoremap <silent> gk :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if &filetype == 'vim'
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

" Highlight symbol under cursor on CursorHold
autocmd CursorHold * silent call CocActionAsync('highlight')

" Remap for rename current word
nmap <leader>rn <Plug>(coc-rename)

" Remap for format selected region
nmap <leader>cf  <Plug>(coc-format-selected)
vmap <leader>cf  <Plug>(coc-format-selected)

augroup mygroup
  autocmd!
  " Setup formatexpr specified filetype(s).
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  " Update signature help on jump placeholder
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
  autocmd ColorScheme * highligh CocErrorSign   ctermfg=9   guifg=#ff0000 guibg=#073642
  autocmd ColorScheme * highligh CocWarningSign ctermfg=130 guifg=#ff922b guibg=#073642
  autocmd ColorScheme * highligh CocInfoSign    ctermfg=11  guifg=#fab005 guibg=#073642
  autocmd ColorScheme * highligh CocHintSign    ctermfg=12  guifg=#15aabf guibg=#073642
augroup end

" Remap for do codeAction of selected region, ex: `<leader>aap` for current paragraph
vmap <leader>cda  <Plug>(coc-codeaction-selected)
nmap <leader>cda  <Plug>(coc-codeaction-selected)

" Remap for do codeAction of current line
nmap <leader>cd  <Plug>(coc-codeaction)
" Fix autofix problem of current line
nmap <leader>cq  <Plug>(coc-fix-current)
" codelens
nmap <leader>cl  <Plug>(coc-codelens-action)

" Use `:Format` for format current buffer
command! -nargs=0 Format :call CocAction('format')

" Use `:Fold` for fold current buffer
command! -nargs=? Fold :call CocAction('fold', <f-args>)

" Using CocList
" Show all diagnostics
nnoremap <silent> <space>ca  :<C-u>CocList diagnostics<cr>
" Search workspace symbols
nnoremap <silent> <space>cs  :<C-u>CocList -I symbols<cr>
" Find symbol of current document
nnoremap <silent> <space>cO  :<C-u>CocList outline<cr>
" Show commands
nnoremap <silent> <space>cm  :<C-u>CocList lists<cr>
" Do default action for next item.
nnoremap <silent> <space>cj  :<C-u>CocNext<CR>
" Do default action for previous item.
nnoremap <silent> <space>ck  :<C-u>CocPrev<CR>
" Resume latest coc list
nnoremap <silent> <space>cu  :<C-u>CocListResume<CR>
'''

[[plugins]]
repo = 'jsfaint/coc-neoinclude'
depends = ['neoinclude.vim']

[[plugins]]
repo = 'tjdevries/coc-zsh'

[[plugins]]
repo = 'Shougo/neoinclude.vim'

[[plugins]]
repo = 'neoclide/coc-neco'
depends = ['neco-vim']

[[plugins]]
repo = 'Shougo/neco-vim'

[[plugins]]
repo = 'Shougo/neosnippet'
depends = ['neosnippet-snippets', 'vim-snippets']
hook_add = '''
imap <expr> <C-Space> pumvisible() ? neosnippet#jumpable()
  \ ? "\<Plug>(neosnippet_jump)" : "\<C-y>" : "\<Plug>(neosnippet_jump_or_expand)"
smap <expr> <C-Space> pumvisible() ? neosnippet#jumpable()
  \ ? "\<Plug>(neosnippet_jump)" : "\<C-y>" : "\<Plug>(neosnippet_jump_or_expand)"
xmap <expr> <C-Space> pumvisible() ? "\<C-y>" : "\<Plug>(neosnippet_expand_target)"

let g:neosnippet#enable_completed_snippet  = 1
let g:neosnippet#expand_word_boundar       = 1
let g:neosnippet#enable_auto_clear_markers = 1
let g:neosnippet#snippets_directory        = '~/.cache/dein/repos/github.com/honza/vim-snippets/snippets/'

" For conceal markers.
if has('conceal')
  set conceallevel=2 concealcursor=niv
  endif
'''

[[plugins]]
repo = 'honza/vim-snippets'

[[plugins]]
repo = 'Shougo/neosnippet-snippets'

[[plugins]]
repo = 'liuchengxu/vista.vim'
on_cmd = ['Vista!!']
hook_add = '''
nnoremap <silent> <Leader>co :Vista!!<CR>
nnoremap <silent> <Leader>c/ :Vista finder coc<CR>
let g:vista_echo_cursor_strategy = "floating_win"
let g:vista_stay_on_open = 0
let g:vista_fzf_preview    = ['right:50%']
let g:vista_icon_indent = ["", " "]
let g:vista#renderer#icons = {
  \  "function": "\uf794 ",
  \  "variable": "\uf71b ",
  \ }
'''

[[plugins]]
repo = 'konfekt/FastFold'
on_event = 'VimEnter'

[[plugins]]
repo = 'wellle/tmux-complete.vim'

# text-----------------------------------

[[plugins]]
repo = 'mattn/emmet-vim'
on_ft = ['html', 'php', 'phtml', 'javascript']
hook_add = '''
let g:user_emmet_install_global        =  0
let g:user_emmet_mode                  = 'iv'
let g:user_emmet_expandabbr_key        = '<M-,>'
let g:user_emmet_expandword_key        = '<M-e>w;'
let g:user_emmet_update_tag            = '<M-e>u'
let g:user_emmet_balancetaginward_key  = '<M-e>d'
let g:user_emmet_balancetagoutward_key = '<M-e>D'
let g:user_emmet_next_key              = '<M-e>n'
let g:user_emmet_prev_key              = '<M-e>N'
let g:user_emmet_imagesize_key         = '<M-e>i'
let g:user_emmet_togglecomment_key     = '<M-e>/'
let g:user_emmet_splitjointag_key      = '<M-e>j'
let g:user_emmet_removetag_key         = '<M-e>k'
let g:user_emmet_anchorizeurl_key      = '<M-e>a'
let g:user_emmet_anchorizesummary_key  = '<M-e>A'
let g:user_emmet_mergelines_key        = '<M-e>m'
let g:user_emmet_codepretty_key        = '<M-e>c'
autocmd MyAutoCmd FileType phtml,html,php,css EmmetInstall
'''

[[plugins]]
repo = 'RRethy/vim-hexokinase'
on_ft = ['css', 'scss']
hook_add = '''
let g:Hexokinase_ftAutoload = ['css', 'scss', 'sass', 'xml']
'''

[[plugins]]
repo = 'alvan/vim-closetag'
on_event = 'InsertEnter'

[[plugins]]
repo = 'inkarkat/vim-SyntaxRange'
on_event = 'VimEnter'
hook_post_source = '''
autocmd MyAutoCmd FileType toml call Syntax_range_dein()
'''

[[plugins]]
repo = 'cohama/lexima.vim'
on_event = 'InsertEnter'
hook_add  =  '''
let g:lexima_no_default_rules = 1
'''
hook_post_source = '''
call SetLeximaAddRule()
'''

[[plugins]]
repo = 'tyru/caw.vim'
on_map = '<Plug>(caw:hatpos:toggle)'
hook_add = '''
nmap <C-_> <Plug>(caw:hatpos:toggle)
vmap <C-_> <Plug>(caw:hatpos:toggle)
'''

[[plugins]]
repo = 'bfredl/nvim-miniyank'
on_event = 'VimEnter'
hook_add = '''
map p <Plug>(miniyank-autoput)
map P <Plug>(miniyank-autoPut)
let g:miniyank_filename = $HOME."/.miniyank.mpack"
let g:miniyank_maxitems = 100
'''

[[plugins]]
repo = 'justinmk/vim-sneak'
on_event = 'VimEnter'
hook_add = '''
map f <Plug>Sneak_f
map F <Plug>Sneak_F
map t <Plug>Sneak_t
map T <Plug>Sneak_T
map ; <Plug>Sneak_;
map , <Plug>Sneak_,
map s <Plug>Sneak_s
map S <Plug>Sneak_S
nmap <expr> f sneak#is_sneaking() ? '<Plug>Sneak_;' : '<plug>Sneak_f'
nmap <expr> F sneak#is_sneaking() ? '<Plug>Sneak_,' : '<plug>Sneak_F'
let g:sneak#s_next = 1
let g:sneak#use_ic_scs = 1
autocmd MyAutoCmd ColorScheme * highligh Sneak cterm=None ctermfg=7 gui=bold,underline guifg=#eee8d5
'''

[[plugins]]
repo = 'mg979/vim-visual-multi'
rev = 'test'
on_event = 'VimEnter'
hook_add = '''
let g:VM_cmdheight       = 1
let g:VM_manual_infoline = 1
let g:VM_leader          = '<Space>v'
let g:VM_theme           = 'iceblue'
'''

[[plugins]]
repo = 'terryma/vim-expand-region'
on_map = '<Plug>(expand_region_expand)'
hook_add = '''
let g:expand_region_text_objects = {
  \ 'iw'  :0,
  \ 'iW'  :0,
  \ 'il'  :0,
  \ 'ii'  :1,
  \ 'i]'  :1,
  \ 'i}'  :1,
  \ 'ib'  :1,
  \ 'iB'  :1,
  \ 'ip'  :0,
  \ 'ie'  :0,
  \ }
'''

[[plugins]]
repo = 'rhysd/accelerated-jk'
on_event = 'VimEnter'
hook_add = '''
nmap j <Plug>(accelerated_jk_gj)
nmap k <Plug>(accelerated_jk_gk)
let g:accelerated_jk_acceleration_table = [15,35,50,74,97,119,141,178]
'''

[[plugins]]
repo = 'easymotion/vim-easymotion'
depends = [
  'incsearch.vim', 'incsearch-fuzzy.vim',
  'incsearch-migemo.vim', 'incsearch-easymotion.vim', 'vim-asterisk'
]
on_event = 'VimEnter'
hook_add = '''
let g:EasyMotion_do_mapping       = 0
let g:EasyMotion_smartcase        = 1
let g:EasyMotion_space_jump_first = 1
let g:incsearch#auto_nohlsearch   = 1
function! s:config_easyfuzzymotion(...) abort
  return extend(copy({
  \   'converters': [incsearch#config#fuzzy#converter()],
  \   'modules'   : [incsearch#config#easymotion#module()],
  \   'keymap'    : {"\<C-Space>": "<Over>(easymotion)", "\<Space>": "\<CR>zz"},
  \   'is_expr'   : 0,
  \   'is_stay'   : 0
  \ }), get(a:, 1, {}))
endfunction
function! s:config_easymotion(...) abort
  return incsearch#util#deepextend(deepcopy({
  \   'modules': [incsearch#config#easymotion#module({'overwin': 1})],
  \   'keymap' : {"\<C-Space>": "<Over>(easymotion)", "\<Space>": "\<CR>zz"},
  \   'is_expr': 0,
  \   'is_stay': 0
  \ }), get(a:, 1, {}))
endfunction
noremap <silent><expr> <Leader>/ incsearch#go(<SID>config_easyfuzzymotion())
noremap <silent><expr> / incsearch#go(<SID>config_easymotion())
noremap <silent><expr> ? incsearch#go(<SID>config_easymotion())
'''

[[plugins]]
repo = 'haya14busa/incsearch-easymotion.vim'

[[plugins]]
repo = 'haya14busa/incsearch.vim'

[[plugins]]
repo = 'haya14busa/incsearch-fuzzy.vim'

[[plugins]]
repo = 'haya14busa/vim-asterisk'
on_event = 'VimEnter'
hook_add = '''
map *   <Plug>(incsearch-nohl0)<Plug>(asterisk-z*)
map g*  <Plug>(incsearch-nohl0)<Plug>(asterisk-gz*)
map #   <Plug>(incsearch-nohl0)<Plug>(asterisk-z#)
map g#  <Plug>(incsearch-nohl0)<Plug>(asterisk-gz#)
'''

[[plugins]]
repo = 'haya14busa/incsearch-migemo.vim'
hook_add = '''
nmap <M-/> <Plug>(incsearch-migemo-/)
'''

[[plugins]]
repo = 'haya14busa/vim-edgemotion'
on_event = 'VimEnter'
hook_add = '''
map J <Plug>(edgemotion-j)
map K <Plug>(edgemotion-k)
'''

[[plugins]]
repo = 'kana/vim-textobj-user'
depends = [
'vim-textobj-entire',  'vim-textobj-indent',      'vim-textobj-php',
'vim-textobj-line',    'vim-textobj-syntax',      'vim-textobj-comment',
'vim-textobj-between', 'vim-textobj-from_regexp', 'vim-textobj-word-column',
'vim-textobj-chunk',   'vim-textobj-space',       'textobj-mbboundary.vim'
]
on_event = 'VimEnter'

[[plugins]]
repo = 'kana/vim-textobj-entire'

[[plugins]]
repo = 'kana/vim-textobj-line'

[[plugins]]
repo = 'kana/vim-textobj-indent'

[[plugins]]
repo = 'thinca/vim-textobj-between'

[[plugins]]
repo = 'kana/vim-textobj-syntax'

[[plugins]]
repo = 'saihoooooooo/vim-textobj-space'

[[plugins]]
repo = 'rhysd/vim-textobj-word-column'

[[plugins]]
repo = 'glts/vim-textobj-comment'
hook_add = '''
let g:textobj_comment_no_default_key_mappings = 1
xmap a/ <Plug>(textobj-comment-a)
omap a/ <Plug>(textobj-comment-a)
xmap i/ <Plug>(textobj-comment-i)
omap i/ <Plug>(textobj-comment-i)
xmap a? <Plug>(textobj-comment-big-a)
omap a? <Plug>(textobj-comment-big-a)
'''

[[plugins]]
repo = 'Chun-Yang/vim-textobj-chunk'

[[plugins]]
repo = 'aikawa9376/vim-textobj-php'

[[plugins]]
repo = 'deton/textobj-mbboundary.vim'
hook_add = '''
let g:mbboundary_no_default_key_mappings = 1
omap <silent> am <Plug>MBBoundaryTextObjA
omap <silent> im <Plug>MBBoundaryTextObjI
xmap <silent> am <Plug>MBBoundaryTextObjVA
xmap <silent> im <Plug>MBBoundaryTextObjVI
'''

[[plugins]]
repo = 'osyo-manga/vim-textobj-from_regexp'
hook_add = '''
" 英数字 + _ を対象とした textobj
omap <expr> i<C-w> textobj#from_regexp#mapexpr('[0-9A-Za-z_.-]\+')
omap <expr> a<C-w> textobj#from_regexp#mapexpr('[0-9A-Za-z_:.$-]\+')
xmap <expr> i<C-w> textobj#from_regexp#mapexpr('[0-9A-Za-z_.-]\+')
xmap <expr> a<C-w> textobj#from_regexp#mapexpr('[0-9A-Za-z_:.$-]\+')
" 英数字のみを対象とした textobj
omap <expr> i<M-w> textobj#from_regexp#mapexpr('[A-Za-z0-9]\+')
xmap <expr> i<M-w> textobj#from_regexp#mapexpr('[A-Za-z0-9]\+')
" 左辺
omap i<C-h> <Plug>(textobj-left-value)
vmap i<C-h> <Plug>(textobj-left-value)
omap <expr>  <Plug>(textobj-left-value)
  \ textobj#from_regexp#mapexpr('^.\{-}\zs\k\+\ze\s*=.*$')
vmap <expr>  <Plug>(textobj-left-value)
  \ textobj#from_regexp#mapexpr('^.\{-}\zs\k\+\ze\s*=.*$')
" 右辺
omap i<C-l> <Plug>(textobj-right-value)
vmap i<C-l> <Plug>(textobj-right-value)
omap <expr> <Plug>(textobj-right-value)
  \ textobj#from_regexp#mapexpr('^.\{-}=\s*\zs.*$')
vmap <expr> <Plug>(textobj-right-value)
  \ textobj#from_regexp#mapexpr('^.\{-}=\s*\zs.*$')
'''

[[plugins]]
repo = 'kana/vim-operator-user'
depends = [
  'vim-operator-replace', 'vim-operator-sort'
]
on_event = 'VimEnter'

[[plugins]]
repo = 'aikawa9376/vim-operator-replace'
hook_add = '''
nmap <Leader>r mv<plug>(operator-replace)
nmap yr mv<plug>(operator-replace_r)
nmap <Leader>R mv<plug>(operator-replace)$
nmap cr mv<plug>(operator-replace_R)
vmap p <Plug>(operator-replace)
'''

[[plugins]]
repo = 'kana/vim-smartchr'
on_event = 'InsertEnter'
hook_add = '''
inoremap <expr> + smartchr#loop('+', ' + ', ' ++ ')
inoremap <expr> - smartchr#loop('-', ' - ', ' -- ')
inoremap <expr> * smartchr#loop('*', ' * ', ' ** ')
inoremap <expr> / smartchr#loop('/', ' / ', ' // ')
inoremap <expr> & smartchr#loop('&', ' & ', ' && ')
inoremap <expr> % smartchr#loop('%', ' % ', ' %% ')
inoremap <expr> > smartchr#loop('>', ' > ', ' >> ')
inoremap <expr> < smartchr#loop('<', ' < ', ' <= ')
inoremap <expr> , smartchr#loop(',', ', ')
" =の場合、単純な代入や比較演算子として入力する場合は前後にスペースをいれる。
" 複合演算代入としての入力の場合は、直前のスペースを削除して=を入力
inoremap <expr> = search('\(&\<bar><bar>\<bar>+\<bar>-\<bar>/\<bar>>\<bar><\) \%#', 'bcn')? '<bs>= '
  \ : search('\(*\<bar>!\)\%#', 'bcn') ? '= '
  \ : smartchr#loop('=', ' = ', ' == ')
" 下記の文字は連続して現れることがまれなので、二回続けて入力したらいろいろする
inoremap <expr> } smartchr#one_of('}', '}<cr>')
inoremap <expr> ; smartchr#loop(';', '$', '@')
" 「->」は入力しづらいので、..で置換え
inoremap <expr> . smartchr#loop('.', '->', '=>')
" if文直後の(は自動で間に空白を入れる
inoremap <expr> ( search('\<\if\%#', 'bcn')? ' (': '('
'''

[[plugins]]
repo = 'emonkak/vim-operator-sort'
hook_add = '''
nmap <Leader>to mv<plug>(operator-sort)
vmap <Leader>to mv<Plug>(operator-sort)
'''

[[plugins]]
repo = 'thinca/vim-submode'
on_event = 'VimEnter'
hook_source = '''
" set lazydrawでカーソルが飛ぶ
let g:submode_timeoutlen = 5000
let g:submode_keep_leaving_key = 1
call submode#enter_with('history', 'n', '', 'g;', 'g;zz')
call submode#enter_with('history', 'n', '', 'g,', 'g,zz')
call submode#map('history', 'n', '', ';', 'g;zz')
call submode#map('history', 'n', '', ',', 'g,zz')
call submode#enter_with('bufmove', 'n', '', '<C-w>+', '<C-w>+')
call submode#enter_with('bufmove', 'n', '', '<C-w>-', '<C-w>-')
call submode#enter_with('bufmove', 'n', '', '<C-w>>', '<C-w>>')
call submode#enter_with('bufmove', 'n', '', '<C-w><', '<C-w><')
call submode#map('bufmove', 'n', '', '+', '<C-w>+')
call submode#map('bufmove', 'n', '', '-', '<C-w>-')
call submode#map('bufmove', 'n', '', '>', '<C-w>>')
call submode#map('bufmove', 'n', '', '<', '<C-w><')
call submode#enter_with('expand-region', 'nv', 'r', 'gw', '<Plug>(expand_region_expand)')
call submode#map('expand-region', 'nv', 'r', 'w', '<Plug>(expand_region_expand)')
call submode#map('expand-region', 'nv', 'r', 'W', '<Plug>(expand_region_shrink)')
call submode#enter_with('block_move', 'n', 'r', '<M-]>', '<Plug>(matchup-z%)zz')
call submode#map('block_move', 'n', 'r', '<M-]>', '<Plug>(matchup-z%)zz')
call submode#map('block_move', 'n', '', '<M-[>', '<C-o>zz')
call submode#enter_with('mini_yank', 'nv', 'r', 'p', '<Plug>(miniyank-autoput)')
call submode#enter_with('mini_yank', 'nv', 'r', 'P', '<Plug>(miniyank-autoPut)')
call submode#map('mini_yank', 'nv', 'r', '<C-n>', '<Plug>(miniyank-cycle)')
call submode#map('mini_yank', 'nv', 'r', '<C-p>', '<Plug>(miniyank-cycleback)')
call submode#enter_with('functionbrace', 'n', '', ']]', ']]')
call submode#enter_with('functionbrace', 'n', '', '[[', '[[')
call submode#map('functionbrace', 'n', '', ']', ']]')
call submode#map('functionbrace', 'n', '', '[', '[[')
call submode#enter_with('bufbrace', 'n', 's', ']b', ':bnext<CR>')
call submode#enter_with('bufbrace', 'n', 's', '[b', ':bpreviou<CR>')
call submode#map('bufbrace', 'n', 's', ']', ':bnext<CR>')
call submode#map('bufbrace', 'n', 's', '[', ':bpreviou<CR>')
call submode#enter_with('chunkbrace', 'n', 's', ']c', ':GitGutterNextHunk<CR>')
call submode#enter_with('chunkbrace', 'n', 's', '[c', ':GitGutterPrevHunk<CR>')
call submode#map('chunkbrace', 'n', 's', ']', ':GitGutterNextHunk<CR>')
call submode#map('chunkbrace', 'n', 's', '[', ':GitGutterPrevHunk<CR>')
call submode#enter_with('quickbrace', 'n', 'r', ']q', '<Plug>(qutefinger-next)')
call submode#enter_with('quickbrace', 'n', 'r', '[q', '<Plug>(qutefinger-prev)')
call submode#map('quickbrace', 'n', 'r', ']', '<Plug>(qutefinger-next)')
call submode#map('quickbrace', 'n', 'r', '[', '<Plug>(qutefinger-prev)')
call submode#enter_with('linterbrace', 'n', 's', '[a', ':call CocAction("diagnosticPrevious")<CR>')
call submode#enter_with('linterbrace', 'n', 's', ']a', ':call CocAction("diagnosticNext")<CR>')
call submode#map('linterbrace', 'n', 's', '[', ':call CocAction("diagnosticPrevious")<CR>')
call submode#map('linterbrace', 'n', 's', ']', ':call CocAction("diagnosticNext")<CR>')
'''

[[plugins]]
repo = 'tpope/vim-surround'
on_event = 'VimEnter'
hook_add = '''
let g:surround_{char2nr("P")} = "<?php \r ?>"
let g:surround_{char2nr("H")} = "<!-- \r -->"
'''

[[plugins]]
repo = 'tpope/vim-repeat'
on_event = 'VimEnter'

[[plugins]]
repo = 'tpope/vim-abolish'
on_event = 'VimEnter'
hook_add = '''
let g:abolish_no_mappings = 1
'''

[[plugins]]
repo = 'machakann/vim-highlightedyank'
on_event = 'VimEnter'

[[plugins]]
repo = 'thirtythreeforty/lessspace.vim'
on_event = 'VimEnter'

[[plugins]]
repo = 'matze/vim-move'
on_event = 'VimEnter'
hook_add = '''
let g:move_map_keys = 0
vmap <M-J> <Plug>MoveBlockDown
vmap <M-K> <Plug>MoveBlockUp
vmap <M-H> <Plug>MoveBlockLeft
vmap <M-L> <Plug>MoveBlockRight
nmap <M-J> <Plug>MoveLineDown
nmap <M-K> <Plug>MoveLineUp
nmap <M-H> <Plug>MoveCharLeft
nmap <M-L> <Plug>MoveCharRight
'''

[[plugins]]
repo = 'andymass/vim-matchup'
on_event = 'VimEnter'
hook_add = '''
nmap <Space><Space> %
vmap <Space><Space> %
nmap <C-Space> <Plug>(matchup-z%)zz
let g:matchup_transmute_enabled = 1
augroup matchup_setting
  autocmd!
  autocmd ColorScheme * hi MatchWord ctermfg=None guifg=None cterm=underline gui=underline
  " coc snippet conflict
  autocmd InsertEnter * let g:matchup_matchparen_enabled = 0
  autocmd InsertLeave * let g:matchup_matchparen_enabled = 1
augroup END
'''

[[plugins]]
repo = 'wellle/targets.vim'
on_event = 'VimEnter'
hook_source = '''
augroup targets_settind
autocmd!
autocmd User targets#mappings#user call targets#mappings#extend({
  \ 'b': {'pair': [
  \      {'o':'(', 'c':')'}, {'o':'[', 'c':']'},
  \      {'o':'{', 'c':'}'}, {'o':'<', 'c':'>'}, {'o':'>', 'c':'<'}
  \ ]},
  \ 'q': {'quote': [{'d':"'"}, {'d':'"'}, {'d':'`'}]},
  \ })
augroup END
'''

[[plugins]]
repo = 'aikawa9376/vim-anzu'
on_event = 'VimEnter'
hook_source = '''
nmap <expr> n anzu#mode#mapexpr("n", "", "zz")
nmap <expr> N anzu#mode#mapexpr("N", "", "zz")
'''

[[plugins]]
repo = 'luochen1990/rainbow'
on_event = 'VimEnter'
hook_add = '''
nmap <silent> <Plug>(my-switch)r :RainbowToggle<CR>
let g:rainbow_active = 0
'''

[[plugins]]
repo = 'aikawa9376/vim-auto-cursorline'
on_event = 'VimEnter'
hook_add = '''
let g:auto_cursorline_wait_ms = 500
augroup cursorline-coc-setting
  autocmd!
  autocmd FileType list let g:auto_cursorline_disable = 1
augroup END
function! EnhanCursor()
  let g:auto_cursorline_disable = 0
  bd
endfunction
'''

[[plugins]]
repo = 'AndrewRadev/splitjoin.vim'
on_cmd = ['SplitjoinJoin', 'SplitjoinSplit']
hook_add = '''
let g:splitjoin_split_mapping = ''
let g:splitjoin_join_mapping = ''
nmap <Leader>tj :SplitjoinJoin<cr>
nmap <Leader>tJ :SplitjoinSplit<cr>
'''

# list-----------------------------------

[[plugins]]
repo = 'shougo/defx.nvim'
depends = ['defx-icons', 'defx-git']
on_cmd = ['Defx']
hook_add = '''
nmap <silent><Space>n :Defx
\ -toggle -resume -direction=topleft -split=vertical
\ -winwidth=35 -columns=indent:git:icons:filename:type<CR>
autocmd MyAutoCmd FileType defx call s:defx_my_settings()
function! s:defx_my_settings() abort
  " Define mappings
  nnoremap <silent><buffer><expr><nowait> <CR>
  \ defx#do_action('drop') . '\<C-w>w'
  nnoremap <silent><buffer><expr><nowait> c
  \ defx#do_action('copy')
  nnoremap <silent><buffer><expr><nowait> m
  \ defx#do_action('move')
  nnoremap <silent><buffer><expr><nowait> p
  \ defx#do_action('paste')
  nnoremap <silent><buffer><expr><nowait> l
  \ defx#do_action('open')
  nnoremap <silent><buffer><expr><nowait> E
  \ defx#do_action('open', 'vsplit')
  nnoremap <silent><buffer><expr><nowait> P
  \ defx#do_action('open', 'pedit')
  nnoremap <silent><buffer><expr><nowait> o
  \ defx#do_action('open_or_close_tree')
  nnoremap <silent><buffer><expr><nowait> K
  \ defx#do_action('new_directory')
  nnoremap <silent><buffer><expr><nowait> N
  \ defx#do_action('new_file')
  nnoremap <silent><buffer><expr><nowait> M
  \ defx#do_action('new_multiple_files')
  nnoremap <silent><buffer><expr><nowait> C
  \ defx#do_action('toggle_columns', 'size:time')
  nnoremap <silent><buffer><expr><nowait> S
  \ defx#do_action('toggle_sort', 'time')
  nnoremap <silent><buffer><expr><nowait> d
  \ defx#do_action('remove')
  nnoremap <silent><buffer><expr><nowait> r
  \ defx#do_action('rename')
  nnoremap <silent><buffer><expr><nowait> !
  \ defx#do_action('execute_command')
  nnoremap <silent><buffer><expr><nowait> x
  \ defx#do_action('execute_system')
  nnoremap <silent><buffer><expr><nowait> yy
  \ defx#do_action('yank_path')
  nnoremap <silent><buffer><expr><nowait> .
  \ defx#do_action('toggle_ignored_files')
  nnoremap <silent><buffer><expr><nowait> ;
  \ defx#do_action('repeat')
  nnoremap <silent><buffer><expr><nowait> h
  \ defx#do_action('cd', ['..'])
  nnoremap <silent><buffer><expr><nowait> ~
  \ defx#do_action('cd')
  nnoremap <silent><buffer><expr><nowait> q
  \ defx#do_action('quit')
  nnoremap <silent><buffer><expr><nowait> <Tab>
  \ defx#do_action('toggle_select') . 'j'
  nnoremap <silent><buffer><expr><nowait> *
  \ defx#do_action('toggle_select_all')
  nnoremap <silent><buffer><expr><nowait> j
  \ line('.') == line('$') ? 'gg' : 'j'
  nnoremap <silent><buffer><expr><nowait> k
  \ line('.') == 1 ? 'G' : 'k'
  nnoremap <silent><buffer><expr><nowait> <C-l>
  \ defx#do_action('redraw')
  nnoremap <silent><buffer><expr><nowait> <C-g>
  \ defx#do_action('print')
  nnoremap <silent><buffer><expr><nowait> <C-n>
  \ ':<C-u>Defx -buffer-name=temp -split=split<CR>'
endfunction
'''

[[plugins]]
repo = 'kristijanhusak/defx-icons'
hook_add = '''
let g:defx_icons_column_length           = 1
let g:defx_icons_enable_syntax_highlight = 1
'''

[[plugins]]
repo = 'kristijanhusak/defx-git'

[[plugins]]
repo = 'LeafCage/qutefinger.vim'
on_event = 'VimEnter'
hook_add = '''
nmap Qz <Plug>(qutefinger-toggle-mode)
nmap Qp <Plug>(qutefinger-older)
nmap Qn <Plug>(qutefinger-newer)
nmap Q  <Plug>(qutefinger-toggle-win)
nmap QQ <Plug>(qutefinger-toggle-win)
'''

[[plugins]]
repo = 'junegunn/fzf'
depends = ['fzf.vim', 'vim-bookmarks', 'tmux-complete.vim']
path = '~/.fzf'
build = './install --all'
merged = 0
on_event = 'VimEnter'

[[plugins]]
repo = 'junegunn/fzf.vim'
hook_add = '''
" fzfからファイルにジャンプできるようにする
let g:fzf_buffers_jump = 1
nnoremap <silent> <Leader>f  m':Files<CR>
nnoremap <silent> <Leader>F  m':AllFiles<CR>
nnoremap <silent> <Leader>gf m':GFiles<CR>
nnoremap <silent> <Leader>gi m':Gitignore<CR>
nnoremap <silent> <Leader>b  m':NavBuffers<CR>
nnoremap <silent> <Leader>a  m':Rg<CR>
nnoremap <silent> <Leader>A  m':AllRg<CR>
nnoremap <silent> <Leader>l  m':BLines<CR>
nnoremap <silent> <Leader>L  m':Lines<CR>
nnoremap <silent> <Leader>e  m':MRUFilesCWD<CR>
nnoremap <silent> <Leader>E  m':MRUFiles<CR>
nnoremap <silent> <Leader>df :SWSqlFzfSelect<CR>
nnoremap <silent> <Leader>.  m':DotFiles<CR>
nnoremap <silent> <Leader>O  m':Outline<CR>
nnoremap <silent> <Leader>M  m':Memo<CR>
nnoremap <silent> <Leader>gc m':BCommits<CR>
nnoremap <silent> <Leader>gC m':Commits<CR>
nnoremap <silent> <Leader>T  :DirWordCompletions<CR>
nnoremap <silent> <Leader>tm :TmuxSearch<CR>
nnoremap <silent> <Leader>p :YanksAfter<CR>
nnoremap <silent> <Leader>P :YanksBefore<CR>
nnoremap <silent> <Leader>; :ChangeListNav<CR>
nnoremap <silent> <Leader><C-o> :JumpListNav<CR>
nnoremap <silent> <Leader>q :Helptags<CR>
nnoremap <silent> <Leader>tt :BTags<CR>
nnoremap <silent> <C-]> m':call fzf#vim#tags(expand('<cword>'))<CR>
nnoremap <silent> <expr> <Leader>] "m':Rg(" . expand("<cword>") . ")<CR>"
nnoremap <silent> q: :History:<CR>
nnoremap <silent> q/ :History/<CR>

imap <M-p> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)

nmap <Leader><tab> <plug>(fzf-maps-n)
imap j<tab> <plug>(fzf-maps-i)
xmap <Leader><tab> <plug>(fzf-maps-x)
omap <Leader><tab> <plug>(fzf-maps-o)

let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-x': 'split',
  \ 'ctrl-v': 'vsplit' }

command! -bang -nargs=? -complete=dir Files
  \ call fzf#vim#files(<q-args>, fzf#wrap('fzf',
  \ {'options': "--no-unicode --preview-window right:wrap --preview 'bat {}'"}))
command! AllFiles call fzf#run({
  \  'source': 'fd -I --type file --follow --hidden --color=always --exclude .git',
  \  'sink': 'edit',
  \  'options': "-m -x +s --no-unicode --preview-window right:wrap --preview 'bat {}'" .
  \             ' --no-unicode --prompt=AllFiles:'.shellescape(pathshorten(getcwd())).'/',
  \  'down': '40%'})
command! -bang -nargs=* Rg
  \ call fzf#vim#grep(
  \   'rg --column --line-number --hidden --ignore-case --no-heading --color=always '.shellescape(<q-args>), 1,
  \   <bang>0 ? fzf#vim#with_preview({'options': '--delimiter : --nth 4.. --no-unicode'}, 'up:60%:wrap')
  \           : fzf#vim#with_preview({'options': '--delimiter : --nth 4.. --no-unicode'}, 'right:50%:hidden:wrap', '?'),
  \   <bang>0)
command! -bang -nargs=* AllRg
  \ call fzf#vim#grep(
  \   'rg --column --line-number --no-ignore --hidden --ignore-case --no-heading --color=always '.shellescape(<q-args>), 1,
  \   <bang>0 ? fzf#vim#with_preview({'options': '--delimiter : --nth 4.. --no-unicode'}, 'up:60%:wrap')
  \           : fzf#vim#with_preview({'options': '--delimiter : --nth 4.. --no-unicode'}, 'right:50%:hidden:wrap', '?'),
  \   <bang>0)
command! -bang Lines
  \ call fzf#vim#lines({'options': '--reverse --height 40%'}, <bang>0)
command! -bang BLines
  \ call fzf#vim#buffer_lines({'options': '--reverse --height 40%'}, <bang>0)

" ------------------------------------------------------------------
" DotFiles EasySearch
" ------------------------------------------------------------------
command! DotFiles execute 'Files ~/dotfiles'

" ------------------------------------------------------------------
" Outline handling
" ------------------------------------------------------------------
function! s:outline_format(lists)
  for list in a:lists
    let linenr = list[2][:len(list[2])-3]
    let line = getline(linenr)
    let idx = stridx(line, list[0])
    let len = len(list[0])
    let list[0] = line[:idx-1] . printf("\x1b[%s%sm%s\x1b[m", 34, '', line[idx:idx+len-1]) . line[idx+len:]
  endfor
  for list in a:lists
    call map(list, "printf('%s', v:val)")
  endfor
  return a:lists
endfunction

function! s:outline_source(tag_cmds)
  if !filereadable(expand('%'))
    throw 'Save the file first'
  endif

  for cmd in a:tag_cmds
    let lines = split(system(cmd), "\n")
    if !v:shell_error
      break
    endif
  endfor
  if v:shell_error
    throw get(lines, 0, 'Failed to extract tags')
  elseif empty(lines)
    throw 'No tags found'
  endif
  return map(s:outline_format(map(lines, 'split(v:val, "\t")')), 'join(v:val, "\t")')
endfunction

function! s:outline_sink(lines)
  if !empty(a:lines)
    let line = a:lines[0]
    execute split(line, "\t")[2]
  endif
endfunction

function! s:outline(...)
  let args = copy(a:000)
  let tag_cmds = [
    \ printf('ctags -f - --sort=no --excmd=number --language-force=%s %s 2>/dev/null', &filetype, expand('%:S')),
    \ printf('ctags -f - --sort=no --excmd=number %s 2>/dev/null', expand('%:S'))]
  return {
    \ 'source':  s:outline_source(tag_cmds),
    \ 'sink*':   function('s:outline_sink'),
    \ 'options': '--reverse +m -d "\t" --with-nth 1 -n 1 --ansi --prompt "Outline> "'}
endfunction

command! -bang Outline call fzf#run(fzf#wrap('outline', s:outline(), <bang>0))

" ------------------------------------------------------------------
" MRU Navigator
" ------------------------------------------------------------------
" MRU handling, limited to current directory
command! MRUFilesCWD call fzf#run({
  \  'source': s:mru_files_for_cwd(),
  \  'sink': 'edit',
  \  'options': '-m -x +s --preview-window right:wrap --preview "bat {}"
  \              --no-unicode --prompt=MRU:'.shellescape(pathshorten(getcwd())).'/',
  \  'down': '40%'})

" This relies on the yegappan/mru plugin for live MRU updating. Also relies on
" the fact that you don't change the location of the file it uses as its cache.
function! s:mru_files_for_cwd()
  return map(filter(
  \  systemlist("sed -n '2,$p' ~/.vim_mru_files"),
  \  "v:val =~ '^" . getcwd() . "' && v:val !~ '__Tagbar__\\|\\[YankRing]\\|fugitive:\\|NERD_tree\\|^/tmp/\\|.git/'"
  \ ), 'fnamemodify(v:val, ":p:.")')
endfunction

" MRU handling, limited to current directory
command! MRUFiles call fzf#run({
  \  'source': s:mru_files_for_all(),
  \  'sink': 'edit',
  \  'options': '-m -x +s --preview-window right:wrap --preview "bat {}"
  \              --no-unicode --prompt=MRU_ALL:'.shellescape(pathshorten(getcwd())).'/',
  \  'down': '40%'})

" This relies on the yegappan/mru plugin for live MRU updating. Also relies on
" the fact that you don't change the location of the file it uses as its cache.
function! s:mru_files_for_all()
  return map(filter(
  \  systemlist("sed -n '2,$p' ~/.vim_mru_files"),
  \  "v:val !~ '__Tagbar__\\|\\[YankRing]\\|fugitive:\\|NERD_tree\\|^/tmp/\\|.git/'"
  \ ), 'fnamemodify(v:val, ":p:.")')
endfunction

" ------------------------------------------------------------------
" TmuxPane complete
" ------------------------------------------------------------------
command! -bang TmuxSearch call fzf#run(fzf#wrap('tmux', {
    \ 'source':tmuxcomplete#list('words', 0),
    \ 'sink*':function('<SID>fzf_insert_at_point'),
    \ 'options': '--reverse +m -d "\t" --with-nth 1 -n 1 --ansi --prompt "Tmux> "'}, <bang>0))

function! s:fzf_insert_at_point(s) abort
  execute "put ='".a:s[0]."'"
endfunction

" use deoplete not need map
" inoremap <expr> <C-l> fzf#complete({'source': tmuxcomplete#list('lines', 0)})
" inoremap <expr> <M-w> fzf#complete({'source': tmuxcomplete#list('words', 0)})

" ------------------------------------------------------------------
" DirectoryWords Selector
" ------------------------------------------------------------------
function! s:fzf_last_word() abort
  " insert 2 normal 1
  let prev_pos = col('.') - 2
  let before_str = getline('.')[0:prev_pos]
  let last_word = matchstr(before_str, '\m\(\k\+\)$')
  return last_word
endfunction

" working dir word completions
command! -nargs=* DirWordCompletions call fzf#run({
  \  'source': s:dir_word_completion(s:fzf_last_word()),
  \  'sink': 'edit',
  \  'options': '-m -x +s --prompt=DirWords:'.shellescape(s:fzf_last_word()),
  \  'down': '40%'})

function! s:dir_word_completion(word)
  return  systemlist("rg --hidden -w -o '" . a:word . "[A-Za-z0-9-_]+' | sed -e 's/^.*://g' | sort | uniq")
endfunction

" imap <expr> <M-k> fzf#complete({
imap <expr> <C-t> fzf#complete({
    \ 'source': <SID>dir_word_completion(<SID>fzf_last_word()),
    \ 'options': '-m -x +s --prompt=DirWord:',
    \ 'down': '40%'})

" ------------------------------------------------------------------
" Directory And FileName Selector
" ------------------------------------------------------------------
imap <expr> <C-_> fzf#complete({
    \ 'source': <SID>dir_file_completion(<SID>fzf_last_word()),
    \ 'options': '-m -x +s --prompt=DirFiles:',
    \ 'down': '40%'})

function! s:dir_file_completion(word)
  " return  systemlist("fd --follow --hidden --color=always --exclude .git '^" . a:word . "' | tr '/' '\n' | sort | uniq")
  return  systemlist("fd --follow --hidden --color=always --exclude .git '^" . a:word . "' | sort | uniq")
endfunction

" ------------------------------------------------------------------
" JunkFile Navigator
" ------------------------------------------------------------------
command! -nargs=* Memo call fzf#run({
  \  'source': s:junk_file_list(),
  \  'sink*': function('<SID>junk_file_sink'),
  \  'options': '-m -x +s --prompt=Memo:'.shellescape(<q-args>),
  \  'down': '40%'})

function! s:junk_file_list()
  return  systemlist("rg --column -n --hidden --ignore-case --color=always '' ~/.cache/junkfile/ | sed -e 's%/home/aikawa/.cache/junkfile/%%g'")
endfunction

function! s:junk_file_sink(line) abort
  execute "edit +" . split(a:line[0], ':')[1] . " ~/.cache/junkfile/" . split(a:line[0], ':')[0]
endfunction

" ------------------------------------------------------------------
" Git Navigator
" ------------------------------------------------------------------
command! -nargs=* Gitignore call fzf#run({
  \  'source': s:ignore_file_list(),
  \  'sink*': function('<SID>ignore_file_sink'),
  \  'options': '--prompt=Gitignore: --query '.shellescape(<q-args>) . ' -m -x +s  ' .
  \  '--header ":: Press C-x:delete ignore lines C-t:toggle C-m:comment toggle" --print-query ' .
  \  '--expect ctrl-x,ctrl-m,ctrl-t',
  \  'down': '40%'})

function! s:ignore_file_list()
  " depends vim rooter
  if exists('*FindRootDirectory') && FindRootDirectory() != ''
    let s:dir = FindRootDirectory()
    return  systemlist("rg --column -n --hidden --ignore-case --color=always '' " . s:dir . "/.gitignore")
  else
    return 'no git repository'
  endif
endfunction

function! s:ignore_file_sink(lines)
  if len(a:lines) < 3
    return
  endif
  let s:dir = FindRootDirectory()
  if a:lines[1] == ''
    let no= split(a:lines[2], ':')[0]
    execute("silent !sed -i -e '" . no . "d' " . s:dir . "/.gitignore &")
    return
  elseif a:lines[1] == 'ctrl-x'
    for w in range(2, len(a:lines) - 1)
      let no= split(a:lines[w], ':')[0]
      execute("silent !sed -i -e '" . no . "d' " . s:dir . "/.gitignore &")
    endfor
  elseif a:lines[1] == 'ctrl-m'
    for w in range(2, len(a:lines) - 1)
      let no= split(a:lines[w], ':')[0]
      let name = split(a:lines[w], ':')[2]
      if name[0] == "#"
        execute('silent !sed -i -e "' . no . 's/^\\#//" ' . s:dir . '/.gitignore &')
      else
        execute('silent !sed -i -e "' . no . 's/^/\\#/" ' . s:dir . '/.gitignore &')
      endif
    endfor
  elseif a:lines[1] == 'ctrl-t'
    execute('AddGitignore')
    call feedkeys(":start\<CR>")
    return
  endif
  " execute("Gina add " . fnamemodify(a:lines[0], ":p"))
  execute('Gitignore ' . a:lines[0])
  call feedkeys(":start\<CR>")
  return
endfunction

command! -nargs=* AddGitignore call fzf#run({
  \  'source': <SID>dir_file_completion(''),
  \  'sink*': function('<SID>add_ignore_file_sink'),
  \  'options': '--prompt=AllGitignore: --query '.shellescape(<q-args>) . ' -m -x +s  ' .
  \  '--header ":: Press C-x:add ignore lines C-t:toggle" --print-query ' .
  \  '--expect ctrl-x,ctrl-t',
  \  'down': '40%'})

function! s:add_ignore_file_sink(lines) abort
  if len(a:lines) < 3
    return
  endif
  if exists('*FindRootDirectory') && FindRootDirectory() != ''
    let s:dir = FindRootDirectory()
  else
    return 'no git repository'
  endif

  if a:lines[1] == 'ctrl-x'
    for w in range(2, len(a:lines) - 1)
      let t = a:lines[w]
      execute("silent !echo " . t . " >> " . s:dir . "/.gitignore")
      execute("Gina rm --cached " . fnamemodify(t, ":p"))
    endfor
    execute('AddGitignore ' . a:lines[0])
    call feedkeys(":start\<CR>")
    return
  elseif a:lines[1] == 'ctrl-t'
    execute('Gitignore')
    call feedkeys(":start\<CR>")
    return
  endif
  execute("Gina rm --cached " . fnamemodify(a:lines[2], ":p"))
  execute("silent !echo " . a:lines[2] . " >> " . s:dir . "/.gitignore")
endfunction

function s:override_gitfiles_sink(lines) abort
  if len(a:lines) < 2
    return
  endif
  if exists('*FindRootDirectory') && FindRootDirectory() != ''
    let s:dir = FindRootDirectory()
  else
    return 'no git repository'
  endif
  if a:lines[0] == 'ctrl-x'
    for w in range(1, len(a:lines) - 1)
      execute("Gina rm --cached " . a:lines[w])
    endfor
    execute('GFiles')
    call feedkeys(":start\<CR>")
    return
  endif
  for w in range(1, len(a:lines) - 1)
    execute("edit ". fnamemodify(a:lines[w], ":p"))
  endfor
endfunction

command! -bang -nargs=? -complete=dir GFiles
  \ call fzf#vim#gitfiles(<q-args>, fzf#wrap('fzf',
  \ {'sink*': function('<SID>override_gitfiles_sink'),
  \  'options': "-m -x +s --no-unicode
  \  --header \":: Press C-x:rm cached\"
  \  --preview-window right:wrap --preview 'bat {}' --expect ctrl-d"}))

" ------------------------------------------------------------------
" YankRing fzf
" ------------------------------------------------------------------
function! FZFYankList() abort
  function! KeyValue(key, val)
    let line = join(a:val[0], '⏎')
    if (a:val[1] ==# 'V')
      let line = '⏎'.line
    endif
    return a:key.' '.line
  endfunction
  return map(miniyank#read(), function('KeyValue'))
endfunction

function! FZFYankHandler(opt, line) abort
  let key = substitute(a:line, ' .*', '', '')
  if !empty(a:line)
    let yanks = miniyank#read()[key]
    call miniyank#drop(yanks, a:opt)
  endif
endfunction

command! YanksAfter call fzf#run(fzf#wrap('YanksAfter', {
\ 'source':  FZFYankList(),
\ 'sink':    function('FZFYankHandler', ['p']),
\ 'options': '--no-sort --prompt="Yanks-p> "',
\ }))

command! YanksBefore call fzf#run(fzf#wrap('YanksBefore', {
\ 'source':  FZFYankList(),
\ 'sink':    function('FZFYankHandler', ['P']),
\ 'options': '--no-sort --prompt="Yanks-P> "',
\ }))

" ------------------------------------------------------------------
" Buffer Navigator
" ------------------------------------------------------------------
function! s:bufopen(lines)
  if len(a:lines) < 3
    return
  endif

  if a:lines[1] == 'ctrl-k'
    execute('bwipeout')
    execute('NavBuffers ' . a:lines[0])
    call feedkeys(":start\<CR>")
    return
  endif

  if a:lines[1] == 'ctrl-d'
    for w in range(2, len(a:lines) - 1)
      let b = a:lines[w]
      let index = matchstr(b, '^\[\([0-9a-f]\+\)\]')
      execute('bwipeout ' . index[1:len(index)-2])
    endfor
    execute('NavBuffers ' . a:lines[0])
    call feedkeys(":start\<CR>")
    return
  endif

  if a:lines[1] == 'ctrl-b'
    let index = matchstr(a:lines[2], '\[\zs[0-9]*\ze\]')
    execute 'buffer ' index
    execute('NavBuffers ' . a:lines[0])
    call feedkeys(":start\<CR>")
    return
  endif

  let b = matchstr(a:lines[2], '\[\zs[0-9]*\ze\]')
  let cmd = get(g:fzf_action, a:lines[1])
  if !empty(cmd)
    execute 'silent ' cmd
    execute 'buffer ' b
    execute('NavBuffers ' . a:lines[0])
    call feedkeys(":start\<CR>")
    return
  endif
  execute 'buffer ' b
endfunction

function! s:strip(str)
  return substitute(a:str, '^\s*\|\s*$', '', 'g')
endfunction

function! s:buflisted()
  return filter(range(1, bufnr('$')), 'buflisted(v:val) && getbufvar(v:val, "&filetype") != "qf"')
endfunction

function! s:format_buffer(b)
  let name = bufname(a:b)
  let name = empty(name) ? '[No Name]' : fnamemodify(name, ":p:~:.")
  let flag = a:b == bufnr('')  ? '%' :
          \ (a:b == bufnr('#') ? '#' : ' ')
  let modified = getbufvar(a:b, '&modified') ? ' [+]' : ''
  let readonly = getbufvar(a:b, '&modifiable') ? '' : ' [RO]'
  let extra = join(filter([modified, readonly], '!empty(v:val)'), '')
  if flag == '%'
    return s:strip(printf("\033[38;2;102;204;0m[%s] %s - %s %s %s\033[0m", a:b, fnamemodify(name, ':t'), fnamemodify(name, ':r'), flag, extra))
  elseif flag == '#'
    return s:strip(printf("\033[38;2;51;153;255m[%s] %s - %s %s %s\033[0m", a:b, fnamemodify(name, ':t'), fnamemodify(name, ':r'), flag, extra))
  else
    return s:strip(printf("[%s] %s - %s %s %s", a:b, fnamemodify(name, ':t'), fnamemodify(name, ':r'), flag, extra))
  endif
endfunction

function! s:sort_buffers(...)
  return copy(a:000)
endfunction

command! -nargs=* NavBuffers
  \ call fzf#run(fzf#wrap('navbuffers', {
  \ 'source':  map(s:buflisted(), 's:format_buffer(v:val)'),
  \ 'sink*':   function('<SID>bufopen'),
  \ 'options': [
  \   '-m', '-x', '--tiebreak=index', '--ansi', '-d',
  \   '\t', '-n', '2,1..2', '--prompt', 'Buf> ', '--query', <q-args>,
  \   '--header', ':: Press C-D Del C-b Preview And Default Key Working',
  \   '--print-query', '--expect=ctrl-d,ctrl-b,ctrl-x,ctrl-v,ctrl-k', '--no-unicode'],
  \   'up': '30%',
  \ }))

" ------------------------------------------------------------------
" ChangeList Navigator
" ------------------------------------------------------------------
function! s:getChenges()
  let listtext = execute("changes")
  let list = reverse(split(listtext, "\n"))
  call remove(list, 0)
  call remove(list, len(list) - 1)
  return list
endfunction

function! s:cursorMove(line)
  let linelist = substitute(a:line[0],'\s\+',",","g")
  execute "call cursor(" . split(linelist, ',')[1] . "," . split(linelist, ',')[2] . ")"
endfunction

command! -nargs=* ChangeListNav call fzf#run({
  \  'source': s:getChenges(),
  \  'sink*':   function('<SID>cursorMove'),
  \  'options': '--reverse -m -x +s --ansi --prompt=ChangeList:',
  \  'down': '40%'})

" ------------------------------------------------------------------
" JumpList Navigator
" ------------------------------------------------------------------
function! s:getjumps()
  let listtext = execute("jumps")
  let list = reverse(split(listtext, "\n"))
  call remove(list, 0)
  call remove(list, len(list) - 1)
  return list
endfunction

function! s:cursorMove(line)
  let linelist = substitute(a:line[0],'\s\+',",","g")
  if filereadable(fnamemodify(split(linelist, ',')[3], ':p'))
    execute "e " . fnamemodify(split(linelist, ',')[3], ':p')
    execute "call cursor(" . split(linelist, ',')[1] . "," . split(linelist, ',')[2] . ")"
  else
    execute "call cursor(" . split(linelist, ',')[1] . "," . split(linelist, ',')[2] . ")"
  endif
endfunction

command! -nargs=* JumpListNav call fzf#run({
  \  'source': s:getjumps(),
  \  'sink*':   function('<SID>cursorMove'),
  \  'options': '--reverse -m -x +s --ansi --prompt=JumpList:',
  \  'down': '40%'})

" ------------------------------------------------------------------
" ColorScheme Viewer
" ------------------------------------------------------------------
function! s:gethighlight()
  let listtext = execute("highlight")
  let list = split(listtext, "\n")
  return list
endfunction

command! -nargs=* HighLight call fzf#run({
  \  'source': s:gethighlight(),
  \  'options': '--reverse -m -x +s --ansi --prompt=Highlight:',
  \  'down': '40%'})

" ------------------------------------------------------------------
" PHP Refactor Menu
" ------------------------------------------------------------------
function! s:getphprefmenu()
  let menus = {
      \ "Rename Local Variable" : "call PhpRenameLocalVariable()" ,
      \ "Rename Class Variable" : "call PhpRenameClassVariable()" ,
      \ "Rename Method" : "call PhpRenameMethod()" ,
      \ "Extract Use" : "call PhpExtractUse()" ,
      \ "Extract Const" : "call PhpExtractConst()" ,
      \ "Extract Class Property" : "call PhpExtractClassProperty()" ,
      \ "Extract Method" : "call PhpExtractMethod()" ,
      \ "Create Property" : "call PhpCreateProperty()" ,
      \ "Detect Unused Use Statements" : "call PhpDetectUnusedUseStatements()" ,
      \ "Align Assigns" : "call PhpAlignAssigns()" ,
      \ "Create setters and getters" : "call PhpCreateGetters()" ,
      \ "Document all code" : "call PhpDocAll()" }
  return menus
endfunction

function! s:getphprefsink(lines) abort
  let menus = <SID>getphprefmenu()
  execute menus[a:lines[0]]
endfunction
command! -nargs=* PhpRefactorringMenu call fzf#run({
  \  'source': sort(keys(s:getphprefmenu())),
  \  'sink*':   function('<SID>getphprefsink'),
  \  'options': '--reverse -m -x +s --ansi --prompt=PhpRefactorMenu:',
  \  'down': '20%'})

" ------------------------------------------------------------------
" QuickFix
" ------------------------------------------------------------------
command! Fq FZFQuickfix
command! FZFQuickfix call fzf#run({
  \  'source':  Get_qf_text_list(),
  \  'sink':    function('s:qf_sink'),
  \  'options': '-m -x +s',
  \  'down':    '40%'})

" QuickFix形式にqfListから文字列を生成する
function! Get_qf_text_list()
  let qflist = getqflist()
  let textList = []
  for i in qflist
    if i.valid
      let textList = add(textList, printf('%s|%d| %s',
        \  bufname(i.bufnr),
        \  i.lnum,
        \  matchstr(i.text, '\s*\zs.*\S')
        \  ))
    endif
  endfor
  return textList
endfunction

" QuickFix形式のstringからtabeに渡す
function! s:qf_sink(line)
    let parts = split(a:line, '\s')
    execute 'tabe ' . parts[0]
endfunction
'''

[[plugins]]
repo = 'mg979/vim-bookmarks'
rev = 'fzf'
hook_add = '''
let g:bookmark_prefer_fzf = 1
nmap ]B <Plug>BookmarkNext
nmap [B <Plug>BookmarkPrev
nmap <Leader>mm  <Plug>BookmarkToggle
nmap <Leader>mi  <Plug>BookmarkAnnotate
nmap <Leader>ma  <Plug>BookmarkShowAll
nmap <Leader>mc  <Plug>BookmarkClear
nmap <Leader>mx  <Plug>BookmarkClearAll
nmap <Leader>mkk <Plug>BookmarkMoveUp
nmap <Leader>mjj <Plug>BookmarkMoveDown
nmap <Leader>mg  <Plug>BookmarkMoveToLine
'''

[[plugins]]
repo = 'majutsushi/tagbar'
on_cmd = ['TagbarToggle']
hook_add = '''
nnoremap <silent> <Leader>o :TagbarToggle<CR>
let g:tagbar_autopreview    = 0
let g:tagbar_compact        = 1
let g:tagbar_autoshowtag    = 1
let g:tagbar_width          = 30
let g:tagbar_previewwin_pos = 'rightbelow'
'''

[[plugins]]
repo = 'junegunn/vim-peekaboo'
on_event = 'VimEnter'
hook_add = '''
let g:peekaboo_delay = 1000
'''

[[plugins]]
repo = 'yegappan/mru'
on_event = 'VimEnter'
hook_add = '''
let g:MRU_Max_Entries = 5000
'''

[[plugins]]
repo = 'simnalamburt/vim-mundo'
on_cmd = ['MundoToggle']
hook_add = '''
nnoremap <silent> <Leader>u :MundoToggle<CR>
'''

[[plugins]]
repo = 'brooth/far.vim'
on_event = 'VimEnter'
hook_add = '''
let g:far#auto_preview = 0
let g:far#source       = 'agnvim'
'''

[[plugins]]
repo = 'wincent/ferret'
on_map = '<Plug>(FerretAck)'
hook_add = '''
nmap <Leader>rr <Plug>(FerretAck)
'''

[[plugins]]
repo = 'Shougo/junkfile.vim'
on_cmd = ['JunkfileOpen']

[[plugins]]
repo = 'aikawa9376/vim-sql-workbench'
on_cmd = ['SWSqlBufferConnect', 'SWSqlFzfSelect', 'SWDbExplorer']
hook_add = '''
let g:sw_sql_name_result_tab  = 0
let g:sw_highlight_resultsets = 0
let g:sw_sqlopen_command      = 'tabnew'
let g:sw_config_dir           = '/home/aikawa/.sqlworkbench'
let g:sw_cache                = '/home/aikawa/.sqlworkbench/cache'
let g:sw_exe                  = '/home/aikawa/Applications/Sql-Workbench/sqlwbconsole.sh'
'''

[[plugins]]
repo = 'christoomey/vim-tmux-navigator'
on_event = 'VimEnter'
hook_add = '''
let g:tmux_navigator_no_mappings = 1
nnoremap <silent><C-w>h :TmuxNavigateLeft<CR>
nnoremap <silent><C-w>j :TmuxNavigateDown<CR>
nnoremap <silent><C-w>k :TmuxNavigateUp<CR>
nnoremap <silent><C-w>l :TmuxNavigateRight<CR>
'''

[[plugins]]
repo = 'ludovicchabant/vim-gutentags'
on_event = 'VimEnter'
hook_add = '''
let g:gutentags_project_root = [
 \ '.root', '.svn', '.git', '.project', '.vim.local',
 \ 'package.json', 'composer.json'
 \ ]
let g:gutentags_ctags_tagfile = '.tags'
let s:vim_tags = expand('~/.cache/tags')
let g:gutentags_cache_dir = s:vim_tags
if !isdirectory(s:vim_tags)
   silent! call mkdir(s:vim_tags, 'p')
endif
'''

# git -----------------------------------

[[plugins]]
repo = 'airblade/vim-gitgutter'
on_event = 'VimEnter'
hook_add = '''
nmap <silent><Leader>gq :GitGutterPreviewHunk<CR>
nmap <silent><Leader>gh :GitGutterStageHunk<CR>
nmap <silent><Leader>gu :GitGutterUndoHunk<CR>
omap ih <Plug>GitGutterTextObjectInnerPending
omap ah <Plug>GitGutterTextObjectOuterPending
xmap ih <Plug>GitGutterTextObjectInnerVisual
xmap ah <Plug>GitGutterTextObjectOuterVisual
let g:gitgutter_sign_added              = "\uf457 "
let g:gitgutter_sign_modified           = "\uf459 "
let g:gitgutter_sign_removed            = "\uf458 "
let g:gitgutter_sign_modified_removed   = "\uf45a "
let g:gitgutter_sign_removed_first_line = "\uf474 "
let g:gitgutter_grep_command = 'rg --hidden --follow --glob "!.git/*"'
'''
hook_post_source = '''
GitGutterEnable
GitGutterSignsDisable
'''

[[plugins]]
repo = 'tpope/vim-fugitive'
on_event = 'VimEnter'
hook_add = '''
nmap <silent> <Space>gs :Gstatus<CR>
nmap <silent> <Space>gd :Gdiff<CR>
nmap <silent> <Space>ga :Gwrite<CR>
nmap <silent> <Space>gb :Gblame -w<CR>
'''

[[plugins]]
repo = 'lambdalisue/gina.vim'
on_cmd = ['Gina']
hook_add = '''
nmap <silent> <Leader>gns :Gina status<CR>
nmap <silent> <Leader>gnb :Gina blame<CR>
nmap <silent> <Leader>gp  :Gina push<CR>
nmap <silent> <Leader>gr  :Gina rm --cached %<CR>
nmap <silent> <Leader>gc  :Gina commit -m 'auto update'<CR>
nmap <silent> <Leader>gA  :bufdo! Gina add %<CR>
'''
hook_source = '''
call gina#custom#command#option(
 \ '/\%(status\|log\|reflog\)',
 \ '--opener', 'split'
 \)
'''

[[plugins]]
repo = 'cohama/agit.vim'
on_cmd = ['Agit']
hook_add = '''
nmap <Leader>gl :Agit<CR>
'''

[[plugins]]
repo = 'iamcco/sran.nvim'
depends = 'git-p.nvim'
on_event = 'VimEnter'
build = 'yarn'

[[plugins]]
repo = 'iamcco/git-p.nvim'
on_event = 'VimEnter'
hook_add = '''
let g:gitp_add_sign                    = "\uf457 "
let g:gitp_modify_sign                 = "\uf459 "
let g:gitp_delete_top_sign             = "\uf458 "
let g:gitp_delete_bottom_sign          = "\uf45a "
let g:gitp_delete_top_and_bottom_sign  = "\uf474 "
let g:gitp_blame_virtual_text          = 0
nmap gm <Plug>(git-p-diff-preview)
nmap <Leader>tg :call <SID>git_p_virtual_toggle()<CR>
function! s:git_p_virtual_toggle()
  if g:gitp_blame_virtual_text == 1
    let g:gitp_blame_virtual_text = 0
  else
    let g:gitp_blame_virtual_text = 1
  endif
endfunction
autocmd MyAutoCmd ColorScheme * highlight link GitPBlameLine          Delimiter
autocmd MyAutoCmd ColorScheme * highlight link GitPAdd                DiffAdd
autocmd MyAutoCmd ColorScheme * highlight link GitPModify             DiffChange
autocmd MyAutoCmd ColorScheme * highlight link GitPDeleteTop          DiffDelete
autocmd MyAutoCmd ColorScheme * highlight link GitPDeleteBottom       DiffDelete
autocmd MyAutoCmd ColorScheme * highlight link GitPDeleteTopAndBottom DiffDelete
'''

# status line ---------------------------

[[plugins]]
repo = 'itchyny/lightline.vim'
on_event = 'VimEnter'
depends = ['lightline-bufferline', 'lightline-colorscheme-nordplus']
hook_add = '''
let g:lightline = {
  \ 'colorscheme': 'nordplus',
  \ 'mode_map': {'c': 'NORMAL'},
  \ 'active': {
    \ 'left': [
      \ ['mode', 'paste', 'spell', 'help'],
      \ ['vm_regions', 'gitgutter', 'project', 'filename'],
    \ ],
    \ 'right': [
        \ ['cocstatus'],
        \ ['lineinfo'],
        \ ['filetype', 'fileencoding', 'charcode'],
        \ ['vm_modes'],
    \   ]
  \ },
  \ 'tabline': {
    \ 'left': [
      \ ['buffers']
    \ ],
    \ 'right': [
      \ ['workbench', 'obsession']
    \ ]
  \ },
  \ 'component': {
    \ 'lineinfo': '☰ %2p%% %2l:%v'
  \ },
  \ 'component_function': {
    \ 'mode'           : 'MyMode',
    \ 'modified'       : 'MyModified',
    \ 'readonly'       : 'MyReadonly',
    \ 'project'        : 'MyProject',
    \ 'filename'       : 'MyFilename',
    \ 'filetype'       : 'MyFiletype',
    \ 'fileencoding'   : 'MyFileencoding',
    \ 'charcode'       : 'MyCharCode',
    \ 'gitgutter'      : 'MyGitGutter',
    \ 'vm_modes'       : 'g:lightline.vm_modes',
    \ 'vm_regions'     : 'g:lightline.vm_regions',
    \ 'obsession'      : 'MyObsession',
    \ 'workbench'      : 'MyWorkbench',
    \ 'cocstatus'      : 'coc#status',
    \ },
  \ 'component_expand': {
    \ 'buffers'        : 'lightline#bufferline#buffers'
  \ },
  \ 'component_type': {
    \ 'linter_checking': 'left',
    \ 'linter_ok'      : 'left',
    \ 'linter_warnings': 'warning',
    \ 'linter_errors'  : 'error',
    \ 'buffers'        : 'tabsel'
  \ },
  \ 'component_function_visible_condition': {
    \ 'vm_modes'       : 'g:lightline.VM()',
    \ 'vm_regions'     : 'g:lightline.VM()',
  \ },
  \ 'separator'        : {'left': "\u2b80", 'right': "\u2b82"},
  \ 'subseparator'     : {'left': "\u2b81", 'right': "\u2b83"}
\ }

function! MyMode()
  return  &ft == 'denite'    ? 'denite' :
        \ &ft == 'defx'      ? 'defx' :
        \ &ft == 'fzf'       ? 'fzf' :
        \ &ft == 'mundo'     ? 'mundo' :
        \ &ft == 'MundoDiff' ? 'diff' :
        \ g:lightline.VM()   ? g:lightline.vm_mode() :
        \ winwidth(0) > 20   ? g:lightline#mode() : ''
endfunction

function! MyModified()
  return &ft =~ 'help\|defx\|mundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyObsession()
  if exists('*ObsessionStatus')
    return ObsessionStatus("\uf0c7", '')
  else
    return ''
  endif
endfunction

function! MyWorkbench()
  if exists('*SWSqlLightLineProfile')
    let s:db = SWSqlLightLineProfile()
    if s:db != ''
      return "\uf472" . ' ' . s:db
    else
      return ''
    endif
  else
    return ''
  endif
endfunction

function! MyReadonly()
  return &ft !~? 'help\|defx\|mundo' && &ro ? "\u2b64" : ''
endfunction

function! MyFilename()
  return WebDevIconsGetFileTypeSymbol() . ' ' . ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
  \ (&ft == 'defx'      ? 'files' :
  \  &ft == 'denite'    ? denite#get_status_string() :
  \  &ft == 'mundo'     ? 'undo' :
  \  &ft == 'MundoDiff' ? 'preview' :
  \  &ft == 'fzf'       ? 'search' :
  \  &ft == 'vimshell'  ? substitute(b:vimshell.current_dir,expand('~'),'~','') :
  \  winwidth(0) < 100  ? expand("%:t") :
  \  '' != @%           ? @% : '[No Name]') .
  \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyRootDir()
  if exists('*FindRootDirectory') && FindRootDirectory() != ''
    let s:dir = FindRootDirectory()
    let s:dir = split(s:dir, '/')
    return "\ue5fe " . s:dir[len(s:dir) - 1]
  else
    return ''
  endif
endfunction

function! MyFugitive()
  try
    if &ft !~? 'help\|defx\|mundo' && exists('*fugitive#head')
      let _ = fugitive#head()
      return strlen(_) ? "\u2b60 "._ : ''
    endif
  catch
  endtry
  return ''
endfunction

function! MyProject()
  let s:prod = ''
  if MyFugitive() != ''
    let s:prod = MyFugitive()
  endif
  if s:prod == ''
    let s:prod = MyRootDir()
  else
    let s:prod = s:prod . ' ' . MyRootDir()
  endif
  return winwidth('.') > 100 ? s:prod : ''
endfunction

function! MyFiletype()
  return winwidth('.') > 70 ? (strlen(&filetype) ? WebDevIconsGetFileTypeSymbol() . ' ' . &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth('.') > 70 ? WebDevIconsGetFileFormatSymbol() . ' ' . (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyGitGutter()
  if ! exists('*GitGutterGetHunkSummary')
  \ || ! get(g:, 'gitgutter_enabled', 0)
  \ || winwidth('.') <= 100
    return ''
  endif
  let symbols = [
    \ g:gitgutter_sign_added    . '',
    \ g:gitgutter_sign_modified . '',
    \ g:gitgutter_sign_removed  . ''
  \ ]
  let hunks = GitGutterGetHunkSummary()
  let ret = []
  for i in [0, 1, 2]
    if hunks[i] > 0
      call add(ret, symbols[i] . hunks[i])
    endif
  endfor
  return winwidth('.') > 70 ? join(ret, ' ') : ''
endfunction

let g:lightline.VM = { -> exists("g:Vm") && g:Vm.is_active }

fun! g:lightline.vm_mode() dict
  if g:lightline.VM()
    call lightline#link('v')
    return "V-MULTI"
  endif
endfun

fun! g:lightline.vm_modes() dict
  if g:lightline.VM()
    let v = g:Vm
    let V = b:VM_Selection.Vars
    let m = v.mappings_enabled ? 'M' : 'm'
    let b = V.block_mode       ? 'B' : 'b'
    let o = V.only_this_always ? 'O' : 'o'
    let l = V.multiline        ? 'V' : 'v'
    return m.b.o.l
  endif
  return ''
endfun

fun! g:lightline.vm_regions() dict
  if g:lightline.VM()
    let V = b:VM_Selection.Vars
    let i = V.index + 1
    let max = len(b:VM_Selection.Regions)
    return i.' / '.max
  endif
  return ''
endfun
'''

[[plugins]]
repo = 'aikawa9376/lightline-bufferline'
hook_add = '''
set showtabline=2
let g:lightline#bufferline#enable_devicons   = 1
let g:lightline#bufferline#filename_modifier = ':t'
let g:lightline#bufferline#show_number       = 1
let g:lightline#bufferline#active_tab_hi     = 1
let g:lightline#bufferline#shorten_pat       = 0
let g:lightline#bufferline#unnamed           = '[No Name]'
'''

[[plugins]]
repo = 'aikawa9376/lightline-colorscheme-nordplus'

# util ----------------------------------

[[plugins]]
repo = 'vim-scripts/BufOnly.vim'
on_event = 'VimEnter'

[[plugins]]
repo = 'moll/vim-bbye'
on_cmd = ['Bdelete', 'Bwipeout']

# php------------------------------------

[[plugins]]
repo = 'StanAngeloff/php.vim'
on_ft = ['html', 'php', 'phtml']

[[plugins]]
repo = 'adoy/vim-php-refactoring-toolbox'
on_ft = ['php', 'phtml']
hook_add = '''
let g:vim_php_refactoring_use_default_mapping = 0
'''

[[plugins]]
repo = 'captbaritone/better-indent-support-for-php-with-html'
on_ft = ['html', 'php', 'phtml']

# javascript & typescript----------------

[[plugins]]
repo = 'HerringtonDarkholme/yats.vim'
on_ft = ['ts', 'javascript']

[[plugins]]
repo = 'burnettk/vim-angular'
on_ft = ['javascript']

# rust----------------------------------

[[plugins]]
repo = 'rust-lang/rust.vim'
on_ft = ['rust']
