# shougo---------------------------------

[[plugins]]
repo = 'Shougo/deoplete.nvim'
depends = [
'neosnippet', 'context_filetype.vim', 'neco-syntax',
'echodoc.vim', 'neoinclude.vim', 'FastFold', 'neopairs.vim',
'tmux-complete.vim', 'phpcd.vim', 'neco-vim', 'deoplete-zsh'
]
hook_source = '''
" deoplete setup
let g:deoplete#enable_at_startup = 1

let s:deoplete_custom_option = {
  \ 'auto_complete'      : v:true,
  \ 'auto_complete_delay': 5,
  \ 'auto_refresh_delay' : 30,
  \ 'camel_case'         : v:false,
  \ 'ignore_case'        : v:true,
  \ 'max_list'           : 100,
  \ 'min_pattern_length' : 1,
  \ 'num_processes'      : 10,
  \ 'on_insert_enter'    : v:true,
  \ 'on_text_changed_i'  : v:true,
  \ 'refresh_always'     : v:false,
  \ 'skip_chars'         : ['(', ')', '[', ']'],
  \ 'smart_case'         : v:true,
  \ }
call deoplete#custom#option(s:deoplete_custom_option)
call deoplete#custom#source('_', 'converter', ['auto_paren'])
call deoplete#custom#source('neosnippet', 'rank', 1000)
call deoplete#custom#source('neosnippet', 'max_candidates', 5)
call deoplete#custom#source('neosnippet', 'max_pattern_length', 3)
call deoplete#custom#source('tag', 'min_pattern_length', 2)
call deoplete#custom#source('tmux-complete', 'min_pattern_length', 2)

let g:deoplete#ignore_sources     = get(g:, 'deoplete#ignore_sources', {})
let g:deoplete#ignore_sources.php = ['omni']

" 戻れてもいいかもしれない
autocmd MyAutoCmd InsertLeave * NeoSnippetClearMarkers
'''
on_event = 'InsertEnter'

[[plugins]]
repo = 'Shougo/neosnippet'
depends = ['neosnippet-snippets']
on_event = 'InsertEnter'
on_ft = ['snippet']
hook_source = '''
" Snippet key-mappings.
" Note: It must be "imap" and "smap".  It uses <Plug> mappings.
imap <C-Space> <Plug>(neosnippet_jump_or_expand)
smap <C-Space> <Plug>(neosnippet_jump_or_expand)
xmap <C-Space> <Plug>(neosnippet_expand_target)

let g:neosnippet#enable_completed_snippet = 1
let g:neosnippet#expand_word_boundar      = 1
let g:neosnippet#snippets_directory       = '~/.config/nvim/snippets'

" For conceal markers.
if has('conceal')
  set conceallevel=2 concealcursor=niv
endif
'''

[[plugins]]
repo = 'autozimu/LanguageClient-neovim'
on_ft = ['rust','javascript','python', 'php']
# depends = ['LanguageServer-phan-neovim']
rev = 'next'
build = 'bash install.sh'
hook_add = '''
set hidden
let g:LanguageClient_serverCommands = {
  \ 'rust': ['~/.cargo/bin/rustup', 'run', 'stable', 'rls'],
  \ 'javascript': ['javascript-typescript-stdio'],
  \ 'python': ['pyls'],
  \ }
let g:LanguageClient_autoStart                = 1
let g:LanguageClient_autoStop                 = 1
let g:LanguageClient_diagnosticsEnable        = 0
let g:LanguageClient_changeThrottle           = 1.5
let g:LanguageClient_completionPreferTextEdit = 0
let g:LanguageClient_diagnosticsSignsMax      = 0
let g:LanguageClient_diagnosticsList          = 'Disabled'
let g:LanguageClient_hasSnippetSupport        = 0
let g:LanguageClient_waitOutputTimeout        = 4
let g:LanguageClient_loadSettings             = 1
let g:LanguageClient_settingsPath             = '.lsp.json'
" let g:LanguageClient_loggingLevel = 'DEBUG'
" let g:LanguageClient_loggingFile = '/tmp/LanguageClient.log'
" let g:LanguageClient_serverStderr = '/tmp/LanguageServer.log'
nnoremap <silent> K :call LanguageClient_textDocument_hover()<CR>
nnoremap <silent> gd :call LanguageClient_textDocument_definition()<CR>
nnoremap <silent> <F2> :call LanguageClient_textDocument_rename()<CR>
nnoremap <silent> <F3> :call LanguageClient_textDocument_references()<CR>
nnoremap <silent> <F11> :call LanguageClient_contextMenu()<CR>
'''

[[plugins]]
repo = 'Shougo/neosnippet-snippets'

[[plugins]]
repo = 'honza/vim-snippets'

[[plugins]]
repo = 'Shougo/context_filetype.vim'
hook_source = '''
if !exists('g:context_filetype#same_filetypes')
  let g:context_filetype#same_filetypes = {}
endif
let g:context_filetype#same_filetypes.php = 'phtml'
let b:context_filetype_filetypes = context_filetype#default_filetypes()
call extend(b:context_filetype_filetypes,
  \ {'php' : [
  \   {
  \    'start':
  \     '<script\%( [^>]*\)\? type="text/javascript"\%( [^>]*\)\?>',
  \    'end': '</script>', 'filetype': 'javascript',
  \   },
  \   {
  \    'start':
  \     '<script\%( [^>]*\)\? type="text/coffeescript"\%( [^>]*\)\?>',
  \    'end': '</script>', 'filetype': 'coffee',
  \   },
  \   {
  \    'start':
  \     '<script\%( [^>]*\)\?>',
  \    'end': '</script>', 'filetype': 'javascript',
  \   },
  \   {
  \    'start':
  \     '<style\%( [^>]*\)\?>',
  \    'end': '</style>', 'filetype': 'css',
  \   },
  \   {
  \    'start':
  \     '<[^>]\+ style=\([''"]\)',
  \    'end': '\1', 'filetype': 'css',
  \   },
  \ ]})
'''

[[plugins]]
repo = 'Shougo/neco-syntax'

[[plugins]]
repo = 'Shougo/neco-vim'

[[plugins]]
repo = 'deoplete-plugins/deoplete-zsh'

[[plugins]]
repo = 'Shougo/echodoc.vim'
hook_add = '''
let g:echodoc#enable_at_startup = 1
let g:echodoc#type = 'virtual'
'''

[[plugins]]
repo = 'Shougo/neoinclude.vim'

[[plugins]]
repo = 'Shougo/neopairs.vim'
hook_add = '''
let g:neopairs#enable = 1
'''
[[plugins]]
repo = 'wellle/tmux-complete.vim'

[[plugins]]
repo = 'konfekt/FastFold'
on_event = 'VimEnter'

# text-----------------------------------

[[plugins]]
repo = 'mattn/emmet-vim'
# on_event = 'insertenter'
on_ft = ['html', 'php', 'phtml', 'javascript']
hook_add = '''
let g:user_emmet_install_global = 0
let g:user_emmet_mode='i'
autocmd MyAutoCmd FileType phtml,html,php,css EmmetInstall
imap <silent> <M-,> <C-y>,
'''

[[plugins]]
repo = 'alvan/vim-closetag'
on_event = 'InsertEnter'

[[plugins]]
repo = 'inkarkat/vim-SyntaxRange'
on_event = 'VimEnter'
hook_post_source = '''
autocmd MyAutoCmd BufEnter,BufRead,InsertLeave dein*.toml call Syntax_range_dein()
'''

[[plugins]]
repo = 'cohama/lexima.vim'
on_event = 'InsertEnter'
hook_post_source = 'call SetLeximaAddRule()'

[[plugins]]
repo = 'tyru/caw.vim'
on_map = '<Plug>(caw:hatpos:toggle)'
hook_add = '''
nmap <C-_> <Plug>(caw:hatpos:toggle)
vmap <C-_> <Plug>(caw:hatpos:toggle)
'''

[[plugins]]
repo = 'thinca/vim-visualstar'
on_event = 'VimEnter'

[[plugins]]
repo = 'bfredl/nvim-miniyank'
on_event = 'VimEnter'
hook_add = '''
map p <Plug>(miniyank-autoput)
map P <Plug>(miniyank-autoPut)
let g:miniyank_filename = $HOME."/.miniyank.mpack"
let g:miniyank_maxitems = 100
'''

[[plugins]]
repo = 'justinmk/vim-sneak'
on_event = 'VimEnter'
hook_add = '''
map f <Plug>Sneak_f
map F <Plug>Sneak_F
map t <Plug>Sneak_t
map T <Plug>Sneak_T
map <C-Space> <Plug>Sneak_s
map <M-S> <Plug>Sneak_S
let g:sneak#s_next = 1
let g:sneak#use_ic_scs = 1
autocmd MyAutoCmd ColorScheme * highligh Sneak ctermbg=0 ctermfg=15 cterm=underline
'''

[[plugins]]
repo = 'mg979/vim-visual-multi'
rev = 'test'
on_event = 'VimEnter'
hook_add = '''
let g:VM_cmdheight       = 1
let g:VM_manual_infoline = 0
let g:VM_leader          = 'vm'
let g:VM_theme           = 'iceblue'
'''

[[plugins]]
repo = 'terryma/vim-expand-region'
on_map = '<Plug>(expand_region_expand)'
hook_add = '''
nmap + <Plug>(expand_region_expand)
vmap + <Plug>(expand_region_expand)
let g:expand_region_text_objects = {
      \ '$'   :0,
      \ 'i]'  :1,
      \ 'ib'  :1,
      \ 'iB'  :1,
      \ 'il'  :0,
      \ 'ip'  :0,
      \ 'ie'  :0,
      \ }
'''

[[plugins]]
repo = 'easymotion/vim-easymotion'
depends = ['incsearch.vim', 'incsearch-fuzzy.vim', 'incsearch-migemo.vim', 'incsearch-easymotion.vim']
on_event = 'VimEnter'
hook_add = '''
let g:EasyMotion_do_mapping       = 0
let g:EasyMotion_smartcase        = 1
let g:EasyMotion_space_jump_first = 1
let g:incsearch#auto_nohlsearch   = 1
" nmap <C-Space> <Plug>(easymotion-overwin-f2)
function! s:config_easyfuzzymotion(...) abort
  return extend(copy({
  \   'converters': [incsearch#config#fuzzy#converter()],
  \   'modules': [incsearch#config#easymotion#module()],
  \   'keymap': {"\<C-Space>": "<Over>(easymotion)", "\<Space>": "\<CR>zz"},
  \   'is_expr': 0,
  \   'is_stay': 0
  \ }), get(a:, 1, {}))
endfunction
function! s:config_easymotion(...) abort
  return extend(copy({
  \   'modules': [incsearch#config#easymotion#module()],
  \   'keymap': {"\<C-Space>": "<Over>(easymotion)", "/": "<Over>(incsearch)", "\<Space>": "\<CR>zz"},
  \   'is_expr': 0,
  \   'is_stay': 0
  \ }), get(a:, 1, {}))
endfunction
noremap <silent><expr> <Space><Space> incsearch#go(<SID>config_easyfuzzymotion())
noremap <silent><expr> / incsearch#go(<SID>config_easymotion())
'''

[[plugins]]
repo = 'haya14busa/incsearch-easymotion.vim'

[[plugins]]
repo = 'haya14busa/incsearch.vim'

[[plugins]]
repo = 'haya14busa/incsearch-fuzzy.vim'

[[plugins]]
repo = 'haya14busa/incsearch-migemo.vim'
hook_add = '''
nmap <M-/> <Plug>(incsearch-migemo-/)
'''

[[plugins]]
repo = 'kana/vim-textobj-user'
depends = [
'vim-textobj-entire', 'vim-textobj-indent', 'vim-textobj-php',
'vim-textobj-line', 'vim-textobj-syntax', 'vim-textobj-comment',
'vim-textobj-between', 'vim-textobj-from_regexp', 'vim-textobj-chunk'
]
on_event = 'VimEnter'

[[plugins]]
repo = 'kana/vim-textobj-entire'

[[plugins]]
repo = 'kana/vim-textobj-line'

[[plugins]]
repo = 'kana/vim-textobj-indent'

[[plugins]]
repo = 'thinca/vim-textobj-between'

[[plugins]]
repo = 'kana/vim-textobj-syntax'

[[plugins]]
repo = 'glts/vim-textobj-comment'
hook_add = '''
let g:textobj_comment_no_default_key_mappings = 1
xmap a/ <Plug>(textobj-comment-a)
omap a/ <Plug>(textobj-comment-a)
xmap i/ <Plug>(textobj-comment-i)
omap i/ <Plug>(textobj-comment-i)
xmap a? <Plug>(textobj-comment-big-a)
omap a? <Plug>(textobj-comment-big-a)
'''

[[plugins]]
repo = 'Chun-Yang/vim-textobj-chunk'

[[plugins]]
repo = 'akiyan/vim-textobj-php'

[[plugins]]
repo = 'osyo-manga/vim-textobj-from_regexp'

[[plugins]]
repo = 'kana/vim-operator-user'
depends = ['vim-operator-replace']
on_map = '<plug>(operator-replace)'
on_event = 'VimEnter'

[[plugins]]
repo = 'kana/vim-operator-replace'
hook_add = '''
nmap <C-s> <plug>(operator-replace)
'''

[[plugins]]
repo = 'thinca/vim-submode'
on_event = 'VimEnter'
hook_source = '''
" set lazydrawでカーソルが飛ぶ
let g:submode_timeoutlen = 5000
let g:submode_keep_leaving_key = 1
call submode#enter_with('history', 'n', '', 'g;', 'g;zz')
call submode#enter_with('history', 'n', '', 'g,', 'g,zz')
call submode#map('history', 'n', '', ';', 'g;zz')
call submode#map('history', 'n', '', ',', 'g,zz')
call submode#enter_with('bufmove', 'n', '', '<C-w>+', '<C-w>+')
call submode#enter_with('bufmove', 'n', '', '<C-w>-', '<C-w>-')
call submode#enter_with('bufmove', 'n', '', '<C-w>>', '<C-w>>')
call submode#enter_with('bufmove', 'n', '', '<C-w><', '<C-w><')
call submode#map('bufmove', 'n', '', '+', '<C-w>+')
call submode#map('bufmove', 'n', '', '-', '<C-w>-')
call submode#map('bufmove', 'n', '', '>', '<C-w>>')
call submode#map('bufmove', 'n', '', '<', '<C-w><')
call submode#enter_with('expand-region', 'nv', 'r', '+', '<Plug>(expand_region_expand)')
call submode#map('expand-region', 'nv', 'r', '+', '<Plug>(expand_region_expand)')
call submode#map('expand-region', 'nv', 'r', '-', '<Plug>(expand_region_shrink)')
call submode#enter_with('block_move', 'n', 'r', '<M-]>', '<Plug>(matchup-z%)zz')
call submode#map('block_move', 'n', 'r', '<M-]>', '<Plug>(matchup-z%)zz')
call submode#map('block_move', 'n', '', '<M-[>', '<C-o>zz')
call submode#enter_with('mini_yank', 'nv', 'r', 'p', '<Plug>(miniyank-autoput)')
call submode#enter_with('mini_yank', 'nv', 'r', 'P', '<Plug>(miniyank-autoPut)')
call submode#map('mini_yank', 'nv', 'r', '<C-n>', '<Plug>(miniyank-cycle)')
call submode#map('mini_yank', 'nv', 'r', '<C-p>', '<Plug>(miniyank-cycleback)')
'''

[[plugins]]
repo = 'tpope/vim-surround'
on_event = 'VimEnter'
hook_add = '''
let g:surround_{char2nr("P")} = "<?php \r ?>"
'''

[[plugins]]
repo = 'tpope/vim-repeat'
on_event = 'VimEnter'

[[plugins]]
repo = 'tpope/vim-abolish'
on_event = 'VimEnter'

[[plugins]]
repo = 'machakann/vim-highlightedyank'
on_event = 'VimEnter'

[[plugins]]
repo = 'thirtythreeforty/lessspace.vim'
on_event = 'VimEnter'

[[plugins]]
repo = 'matze/vim-move'
on_event = 'VimEnter'

[[plugins]]
repo = 'andymass/vim-matchup'
on_event = 'VimEnter'
hook_add = '''
" nmap <silent> <Plug>(matchup-z%-origin) :<C-u>call matchup#motion#jump_inside(0)<CR>zz
" nmap <M-]> <Plug>(matchup-z%)zz
autocmd MyAutoCmd ColorScheme * hi MatchWord ctermfg=None guifg=None cterm=underline gui=underline
let g:matchup_transmute_enabled = 1
'''

[[plugins]]
repo = 'wellle/targets.vim'
on_event = 'VimEnter'

[[plugins]]
repo = 'aikawa9376/vim-anzu'
on_event = 'VimEnter'
hook_source = '''
" mapping
" silent_substitute -> virtualtext
nmap <expr> n anzu#mode#mapexpr("n", "", "zz")
nmap <expr> N anzu#mode#mapexpr("N", "", "zz")
" nmap <expr> * anzu#mode#mapexpr("*", "", "zz")
" nmap <expr> # anzu#mode#mapexpr("#", "", "zz")
'''

[[plugins]]
repo = 'luochen1990/rainbow'
on_event = 'VimEnter'
hook_add = '''
nmap <silent> <F10> :RainbowToggle<CR>
let g:rainbow_active = 0
'''

[[plugins]]
repo = 'chrisbra/unicode.vim'
on_event = 'VimEnter'

# list-----------------------------------

[[plugins]]
repo = 'Shougo/defx.nvim'
depends = ['defx-icons', 'defx-git']
on_cmd = ['Defx']
hook_add = '''
nmap <silent><Space>n :Defx
\ -toggle -resume=true -direction=topleft -split=vertical
\ -winwidth=35 -columns=git:icons:filename:type<CR>
autocmd MyAutoCmd FileType defx call s:defx_my_settings()
function! s:defx_my_settings() abort
" Define mappings
nnoremap <silent><buffer><expr> <CR>
\ defx#async_action('drop')
nnoremap <silent><buffer><expr> c
\ defx#do_action('copy')
nnoremap <silent><buffer><expr> !
\ defx#do_action('execute_command')
nnoremap <silent><buffer><expr> m
\ defx#do_action('move')
nnoremap <silent><buffer><expr> p
\ defx#do_action('paste')
nnoremap <silent><buffer><expr> l
\ defx#async_action('open')
nnoremap <silent><buffer><expr> E
\ defx#do_action('open', 'vsplit')
nnoremap <silent><buffer><expr> P
\ defx#do_action('open', 'pedit')
nnoremap <silent><buffer><expr> K
\ defx#do_action('new_directory')
nnoremap <silent><buffer><expr> N
\ defx#do_action('new_file')
nnoremap <silent><buffer><expr> d
\ defx#do_action('remove_trash')
nnoremap <silent><buffer><expr> r
\ defx#do_action('rename')
nnoremap <silent><buffer><expr> x
\ defx#do_action('execute_system')
nnoremap <silent><buffer><expr> >
\ defx#do_action('toggle_ignored_files')
nnoremap <silent><buffer><expr> .
\ defx#do_action('repeat')
nnoremap <silent><buffer><expr> yy
\ defx#do_action('yank_path')
nnoremap <silent><buffer><expr> h
\ defx#do_action('cd', ['..'])
nnoremap <silent><buffer><expr> ~
\ defx#do_action('cd')
nnoremap <silent><buffer><expr> \
\ defx#do_action('cd', getcwd())
nnoremap <silent><buffer><expr> q
\ defx#do_action('quit')
nnoremap <silent><buffer><expr> <Space>
\ defx#do_action('toggle_select') . 'j'
nnoremap <silent><buffer><expr> *
\ defx#do_action('toggle_select_all')
nnoremap <silent><buffer><expr> j
\ line('.') == line('$') ? 'gg' : 'j'
nnoremap <silent><buffer><expr> k
\ line('.') == 1 ? 'G' : 'k'
nnoremap <silent><buffer><expr> <C-l>
\ defx#do_action('redraw')
nnoremap <silent><buffer><expr> <C-g>
\ defx#do_action('print')
nnoremap <silent><buffer><expr> <Tab> winnr('$') != 1 ?
\ ':<C-u>wincmd w<CR>' :
\ ':<C-u>Defx -buffer-name=temp -split=vertical<CR>'
endfunction
'''

[[plugins]]
repo = 'kristijanhusak/defx-icons'
hook_add = '''
let g:defx_icons_enable_syntax_highlight = 0
let g:defx_icons_column_length = 1
'''

[[plugins]]
repo = 'kristijanhusak/defx-git'

[[plugins]]
repo = 'junegunn/fzf'
depends = ['fzf.vim', 'vim-bookmarks']
path = '~/.fzf'
build = './install --all'
merged = 0
on_event = 'VimEnter'

[[plugins]]
repo = 'junegunn/fzf.vim'
hook_add = '''
" fzfからファイルにジャンプできるようにする
let g:fzf_buffers_jump = 1
nnoremap <silent> <Leader>f :Files<CR>
nnoremap <silent> <Leader>gf :GFiles<CR>
nnoremap <silent> <Leader>b :NavBuffers<CR>
nnoremap <silent> <Leader>a :Rg<CR>
nnoremap <silent> <Leader>l :Lines<CR>
nnoremap <silent> <Leader>e :MRUFilesCWD<CR>
nnoremap <silent> <Leader>. :DotFiles<CR>
nnoremap <silent> <Leader>O :Outline<CR>
nnoremap <silent> <Leader>M :Memo<CR>
nnoremap <silent> <Leader>gc :BCommits<CR>
nnoremap <silent> <Leader>gC :Commits<CR>
nnoremap <silent> <Leader>T :DirWordCompletions<CR>
nnoremap <silent> <Leader>t :TmuxSearch<CR>
" <C-]>でタグ検索 TODO タグファイルが無ければもともとの機能に割り振る
nnoremap <silent> <C-]> :call fzf#vim#tags(expand('<cword>'))<CR>
" <Leader>]で使用箇所検索
nnoremap <silent> <expr> <Leader>] ':Rg(' . expand('<cword>') . ')<CR>'
nnoremap <silent> <Leader>p :YanksAfter<CR>
nnoremap <silent> <Leader>P :YanksBefore<CR>
nnoremap <silent> <Leader>; :ChangeListNav<CR>
nnoremap <silent> <Leader><C-o> :JumpListNav<CR>
nnoremap <silent> q: :History:<CR>
nnoremap <silent> q/ :History/<CR>

imap <M-p> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)

nmap <Leader><tab> <plug>(fzf-maps-n)
imap j<tab> <plug>(fzf-maps-i)
xmap <Leader><tab> <plug>(fzf-maps-x)
omap <Leader><tab> <plug>(fzf-maps-o)

let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-x': 'split',
  \ 'ctrl-v': 'vsplit' }

command! -bang -nargs=? -complete=dir Files
  \ call fzf#vim#files(<q-args>, fzf#wrap('fzf',
  \ {'options': "--preview 'pygmentize -g {}'"}))
command! -bang -nargs=* Ag
  \ call fzf#vim#ag(<q-args>, fzf#wrap('ag',
  \ {'options': "--preview 'pygmentize -g $(cut -d: -f1 <<< {}) | sed -n $(cut -d: -f2 <<< {}),\\$p | head -".&lines."'"}))
command! -bang -nargs=* Rg
  \ call fzf#vim#grep(
  \   'rg --column --line-number --hidden --ignore-case --no-heading --color=always '.shellescape(<q-args>), 1,
  \   <bang>0 ? fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'up:60%')
  \           : fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'right:50%:hidden', '?'),
  \   <bang>0)
command! -bang Lines
  \ call fzf#vim#lines({'options': '--reverse --height 40%'}, <bang>0)

" ------------------------------------------------------------------
" DotFiles EasySearch
" ------------------------------------------------------------------
command! DotFiles execute 'Files ~/dotfiles'

" ------------------------------------------------------------------
" Outline handling
" ------------------------------------------------------------------
function! s:outline_format(lists)
  for list in a:lists
    let linenr = list[2][:len(list[2])-3]
    let line = getline(linenr)
    let idx = stridx(line, list[0])
    let len = len(list[0])
    let list[0] = line[:idx-1] . printf("\x1b[%s%sm%s\x1b[m", 34, '', line[idx:idx+len-1]) . line[idx+len:]
  endfor
  for list in a:lists
    call map(list, "printf('%s', v:val)")
  endfor
  return a:lists
endfunction

function! s:outline_source(tag_cmds)
  if !filereadable(expand('%'))
    throw 'Save the file first'
  endif

  for cmd in a:tag_cmds
    let lines = split(system(cmd), "\n")
    if !v:shell_error
      break
    endif
  endfor
  if v:shell_error
    throw get(lines, 0, 'Failed to extract tags')
  elseif empty(lines)
    throw 'No tags found'
  endif
  return map(s:outline_format(map(lines, 'split(v:val, "\t")')), 'join(v:val, "\t")')
endfunction

function! s:outline_sink(lines)
  if !empty(a:lines)
    let line = a:lines[0]
    execute split(line, "\t")[2]
  endif
endfunction

function! s:outline(...)
  let args = copy(a:000)
  let tag_cmds = [
    \ printf('ctags -f - --sort=no --excmd=number --language-force=%s %s 2>/dev/null', &filetype, expand('%:S')),
    \ printf('ctags -f - --sort=no --excmd=number %s 2>/dev/null', expand('%:S'))]
  return {
    \ 'source':  s:outline_source(tag_cmds),
    \ 'sink*':   function('s:outline_sink'),
    \ 'options': '--reverse +m -d "\t" --with-nth 1 -n 1 --ansi --prompt "Outline> "'}
endfunction

command! -bang Outline call fzf#run(fzf#wrap('outline', s:outline(), <bang>0))

" ------------------------------------------------------------------
" MRU Navigator
" ------------------------------------------------------------------
" MRU handling, limited to current directory
command! MRUFilesCWD call fzf#run({
  \  'source': s:mru_files_for_cwd(),
  \  'sink': 'edit',
  \  'options': '-m -x +s --prompt=MRU:'.shellescape(pathshorten(getcwd())).'/',
  \  'down': '40%'})

" This relies on the yegappan/mru plugin for live MRU updating. Also relies on
" the fact that you don't change the location of the file it uses as its cache.
function! s:mru_files_for_cwd()
  return map(filter(
  \  systemlist("sed -n '2,$p' ~/.vim_mru_files"),
  \  "v:val =~ '^" . getcwd() . "' && v:val !~ '__Tagbar__\\|\\[YankRing]\\|fugitive:\\|NERD_tree\\|^/tmp/\\|.git/'"
  \ ), 'fnamemodify(v:val, ":p:.")')
endfunction

" ------------------------------------------------------------------
" TmuxPane complete
" ------------------------------------------------------------------
command! -bang TmuxSearch call fzf#run(fzf#wrap('tmux', {
    \ 'source':tmuxcomplete#list('words', 0),
    \ 'sink*':function('<SID>fzf_insert_at_point'),
    \ 'options': '--reverse +m -d "\t" --with-nth 1 -n 1 --ansi --prompt "Tmux> "'}, <bang>0))

function! s:fzf_insert_at_point(s) abort
  execute "put ='".a:s."'"
endfunction

" use deoplete not need map
" inoremap <expr> <C-l> fzf#complete({'source': tmuxcomplete#list('lines', 0)})
" inoremap <expr> <M-w> fzf#complete({'source': tmuxcomplete#list('words', 0)})

" ------------------------------------------------------------------
" DirectoryWords Selector
" ------------------------------------------------------------------
function! s:fzf_last_word() abort
  " insert 2 normal 1
  let prev_pos = col('.') - 2
  let before_str = getline('.')[0:prev_pos]
  let last_word = matchstr(before_str, '\m\(\k\+\)$')
  return last_word
endfunction

" working dir word completions
command! -nargs=* DirWordCompletions call fzf#run({
  \  'source': s:dir_word_completion(s:fzf_last_word()),
  \  'sink': 'edit',
  \  'options': '-m -x +s --prompt=DirWords:'.shellescape(s:fzf_last_word()),
  \  'down': '40%'})

function! s:dir_word_completion(word)
  return  systemlist("rg --hidden -w -o '" . a:word . "[A-Za-z0-9-_]+' | sed -e 's/^.*://g' | sort | uniq")
endfunction

" imap <expr> <M-k> fzf#complete({
imap <expr> <C-t> fzf#complete({
    \ 'source': <SID>dir_word_completion(<SID>fzf_last_word()),
    \ 'options': '-m -x +s --prompt=DirWord:',
    \ 'down': '40%'})

" ------------------------------------------------------------------
" Directory And FileName Selector
" ------------------------------------------------------------------
imap <expr> <C-_> fzf#complete({
    \ 'source': <SID>dir_file_completion(<SID>fzf_last_word()),
    \ 'options': '-m -x +s --prompt=DirFiles:',
    \ 'down': '40%'})

function! s:dir_file_completion(word)
  return  systemlist("fd --type file --follow --hidden --color=always --exclude .git '^" . a:word . "' | tr '/' '\n' | sort | uniq")
endfunction

" ------------------------------------------------------------------
" JunkFile Navigator
" ------------------------------------------------------------------
command! -nargs=* Memo call fzf#run({
  \  'source': s:junk_file_list(),
  \  'sink*': function('<SID>junk_file_sink'),
  \  'options': '-m -x +s --prompt=Memo:'.shellescape(<q-args>),
  \  'down': '40%'})

function! s:junk_file_list()
  return  systemlist("rg --column -n --hidden --ignore-case --color=always '' ~/.cache/junkfile/ | sed -e 's%/home/aikawa/.cache/junkfile/%%g'")
endfunction

function! s:junk_file_sink(line) abort
  execute "edit +" . split(a:line[0], ':')[1] . " ~/.cache/junkfile/" . split(a:line[0], ':')[0]
endfunction

" ------------------------------------------------------------------
" YankRing fzf
" ------------------------------------------------------------------
function! FZFYankList() abort
  function! KeyValue(key, val)
    let line = join(a:val[0], '⏎')
    if (a:val[1] ==# 'V')
      let line = '⏎'.line
    endif
    return a:key.' '.line
  endfunction
  return map(miniyank#read(), function('KeyValue'))
endfunction

function! FZFYankHandler(opt, line) abort
  let key = substitute(a:line, ' .*', '', '')
  if !empty(a:line)
    let yanks = miniyank#read()[key]
    call miniyank#drop(yanks, a:opt)
  endif
endfunction

command! YanksAfter call fzf#run(fzf#wrap('YanksAfter', {
\ 'source':  FZFYankList(),
\ 'sink':    function('FZFYankHandler', ['p']),
\ 'options': '--no-sort --prompt="Yanks-p> "',
\ }))

command! YanksBefore call fzf#run(fzf#wrap('YanksBefore', {
\ 'source':  FZFYankList(),
\ 'sink':    function('FZFYankHandler', ['P']),
\ 'options': '--no-sort --prompt="Yanks-P> "',
\ }))

" ------------------------------------------------------------------
" Buffer Navigator
" ------------------------------------------------------------------
function! s:bufopen(lines)
  if len(a:lines) < 3
    return
  endif

  if a:lines[1] == 'ctrl-k'
    execute('bwipeout')
    execute('NavBuffers ' . a:lines[0])
    call feedkeys(":start\<CR>")
    return
  endif

  if a:lines[1] == 'ctrl-d'
    for w in range(2, len(a:lines) - 1)
      let b = a:lines[w]
      let index = matchstr(b, '^\[\([0-9a-f]\+\)\]')
      execute('bwipeout ' . index[1:len(index)-2])
    endfor
    execute('NavBuffers ' . a:lines[0])
    call feedkeys(":start\<CR>")
    return
  endif

  if a:lines[1] == 'ctrl-b'
    let index = matchstr(a:lines[2], '\[\zs[0-9]*\ze\]')
    execute 'buffer ' index
    execute('NavBuffers ' . a:lines[0])
    call feedkeys(":start\<CR>")
    return
  endif

  let b = matchstr(a:lines[2], '\[\zs[0-9]*\ze\]')
  let cmd = get(g:fzf_action, a:lines[1])
  if !empty(cmd)
    execute 'silent ' cmd
    execute 'buffer ' b
    execute('NavBuffers ' . a:lines[0])
    call feedkeys(":start\<CR>")
    return
  endif
  execute 'buffer ' b
endfunction

command! -nargs=* NavBuffers
  \ call fzf#vim#buffers(<q-args>, fzf#wrap('navbuffers', {
  \ 'sink*':   function('<SID>bufopen'),
  \ 'options': [
  \   '-m', '-x', '--tiebreak=index', '--header-lines=1', '--ansi', '-d',
  \   '\t', '-n', '2,1..2', '--prompt', 'Buf> ', '--query', <q-args>,
  \   '--header', ':: Press C-D Del C-b Preview And Default Key Working',
  \   '--print-query', '--expect=ctrl-d,ctrl-b,ctrl-x,ctrl-v,ctrl-k',
  \   '--preview-window', 'up:1:wrap', '--preview', 'echo {} | rev | cut -d "/" -f1 | rev'],
  \   'left': '20%',
  \ }))

" ------------------------------------------------------------------
" ChangeList Navigator
" ------------------------------------------------------------------
function! s:getChenges()
  let listtext = execute("changes")
  let list = reverse(split(listtext, "\n"))
  call remove(list, 0)
  call remove(list, len(list) - 1)
  return list
endfunction

function! s:cursorMove(line)
  let linelist = substitute(a:line[0],'\s\+',",","g")
  execute "call cursor(" . split(linelist, ',')[1] . "," . split(linelist, ',')[2] . ")"
endfunction

command! -nargs=* ChangeListNav call fzf#run({
  \  'source': s:getChenges(),
  \  'sink*':   function('<SID>cursorMove'),
  \  'options': '--reverse -m -x +s --ansi --prompt=ChangeList:',
  \  'down': '40%'})

" ------------------------------------------------------------------
" JumpList Navigator
" ------------------------------------------------------------------
function! s:getjumps()
  let listtext = execute("jumps")
  let list = reverse(split(listtext, "\n"))
  call remove(list, 0)
  call remove(list, len(list) - 1)
  return list
endfunction

function! s:cursorMove(line)
  let linelist = substitute(a:line[0],'\s\+',",","g")
  if filereadable(fnamemodify(split(linelist, ',')[3], ':p'))
    execute "e " . fnamemodify(split(linelist, ',')[3], ':p')
    execute "call cursor(" . split(linelist, ',')[1] . "," . split(linelist, ',')[2] . ")"
  else
    execute "call cursor(" . split(linelist, ',')[1] . "," . split(linelist, ',')[2] . ")"
  endif
endfunction

command! -nargs=* JumpListNav call fzf#run({
  \  'source': s:getjumps(),
  \  'sink*':   function('<SID>cursorMove'),
  \  'options': '--reverse -m -x +s --ansi --prompt=JumpList:',
  \  'down': '40%'})

" ------------------------------------------------------------------
" ColorScheme Viewer
" ------------------------------------------------------------------
function! s:gethighlight()
  let listtext = execute("highlight")
  let list = split(listtext, "\n")
  return list
endfunction

command! -nargs=* HighLight call fzf#run({
  \  'source': s:gethighlight(),
  \  'options': '--reverse -m -x +s --ansi --prompt=Highlight:',
  \  'down': '40%'})

" ------------------------------------------------------------------
" PHP Refactor Menu
" ------------------------------------------------------------------
function! s:getphprefmenu()
  let menus = {
      \ "Rename Local Variable" : "call PhpRenameLocalVariable()" ,
      \ "Rename Class Variable" : "call PhpRenameClassVariable()" ,
      \ "Rename Method" : "call PhpRenameMethod()" ,
      \ "Extract Use" : "call PhpExtractUse()" ,
      \ "Extract Const" : "call PhpExtractConst()" ,
      \ "Extract Class Property" : "call PhpExtractClassProperty()" ,
      \ "Extract Method" : "call PhpExtractMethod()" ,
      \ "Create Property" : "call PhpCreateProperty()" ,
      \ "Detect Unused Use Statements" : "call PhpDetectUnusedUseStatements()" ,
      \ "Align Assigns" : "call PhpAlignAssigns()" ,
      \ "Create setters and getters" : "call PhpCreateGetters()" ,
      \ "Document all code" : "call PhpDocAll()" }
  return menus
endfunction

function! s:getphprefsink(lines) abort
  let menus = <SID>getphprefmenu()
  execute menus[a:lines[0]]
endfunction
command! -nargs=* PhpRefactorringMenu call fzf#run({
  \  'source': sort(keys(s:getphprefmenu())),
  \  'sink*':   function('<SID>getphprefsink'),
  \  'options': '--reverse -m -x +s --ansi --prompt=PhpRefactorMenu:',
  \  'down': '20%'})
'''

[[plugins]]
repo = 'mg979/vim-bookmarks'
rev = 'fzf'
hook_add = '''
let g:bookmark_prefer_fzf = 1
nmap <Leader>mm <Plug>BookmarkToggle
nmap <Leader>mi <Plug>BookmarkAnnotate
nmap <Leader>ma <Plug>BookmarkShowAll
nmap ]b <Plug>BookmarkNext
nmap [b <Plug>BookmarkPrev
nmap <Leader>mc <Plug>BookmarkClear
nmap <Leader>mx <Plug>BookmarkClearAll
nmap <Leader>mkk <Plug>BookmarkMoveUp
nmap <Leader>mjj <Plug>BookmarkMoveDown
nmap <Leader>mg <Plug>BookmarkMoveToLine
'''

[[plugins]]
repo = 'majutsushi/tagbar'
on_cmd = ['TagbarToggle']
hook_add = '''
nnoremap <silent> <Leader>o :TagbarToggle<CR>
let g:tagbar_autopreview    = 1
let g:tagbar_compact        = 1
let g:tagbar_autoshowtag    = 1
let g:tagbar_width          = 40
let g:tagbar_previewwin_pos = 'rightbelow'
'''

[[plugins]]
repo = 'junegunn/vim-peekaboo'
on_event = 'VimEnter'

[[plugins]]
repo = 'yegappan/mru'
on_event = 'VimEnter'
hook_add = '''
let g:MRU_Max_Entries = 1000
'''

[[plugins]]
repo = 'simnalamburt/vim-mundo'
on_cmd = ['MundoToggle']
hook_add = '''
nnoremap U :MundoToggle<CR>
'''

[[plugins]]
repo = 'brooth/far.vim'
on_event = 'VimEnter'
hook_add = '''
" not work nvim(python-nvim?) version
let g:far#source = 'agnvim'
let g:far#auto_preview = 0
" let g:far#source = 'ag'
'''

[[plugins]]
repo = 'wincent/ferret'
on_map = '<Plug>(FerretLack)'
hook_add = '''
nmap <Leader>r <Plug>(FerretLack)
'''

[[plugins]]
repo = 'Shougo/junkfile.vim'
on_cmd = ['JunkfileOpen']

[[plugins]]
repo = 'tpope/vim-dadbod'

[[plugins]]
repo = 'christoomey/vim-tmux-navigator'
on_event = 'VimEnter'
hook_add = '''
let g:tmux_navigator_no_mappings = 1
nnoremap <silent><C-w>h :TmuxNavigateLeft<CR>
nnoremap <silent><C-w>j :TmuxNavigateDown<CR>
nnoremap <silent><C-w>k :TmuxNavigateUp<CR>
nnoremap <silent><C-w>l :TmuxNavigateRight<CR>
'''

# git------------------------------------

[[plugins]]
repo = 'lambdalisue/gina.vim'
on_cmd = ['Gina']
hook_add = '''
nmap <Leader>gns :Gina status<CR>
nmap <Leader>gnb :Gina blame<CR>
nmap <Leader>gp  :Gina push<CR>
nmap <Leader>gnc :Gina commit -m 'auto update'<CR>
nmap <Leader>gA  :Gina add .<CR>
'''
hook_source = '''
call gina#custom#command#option(
 \ '/\%(status\|log\|reflog\)',
 \ '--opener', 'split'
 \)
'''

[[plugins]]
repo = 'cohama/agit.vim'
on_cmd = ['Agit']
hook_add = '''
nmap <Leader>gl :Agit<CR>
'''

# lint & lsp & sources-------------------

[[plugins]]
repo = 'w0rp/ale'
hook_add = '''
" 有効にするformatter
let g:ale_fixers = {
\   'javascript': ['prettier'],
\   'css'       : ['prettier'],
\   'scss'      : ['prettier'],
\}
" 有効にするlinter
let g:ale_linters = {
\   'php'       : ['psalm', 'php'],
\   'vim'       : ['vint'],
\   'javascript': ['eslint'],
\}
" エラー行に表示するマーク
let g:ale_sign_error            = '❌'
let g:ale_sign_warning          = '⚠'
let g:ale_fix_on_save           = 1
let g:ale_lint_on_text_changed  = 0
let g:ale_lint_on_insert_leave  = 1
let g:ale_sign_column_always    = 1
let g:ale_set_loclist           = 0
let g:ale_set_quickfix          = 0
let g:ale_open_list             = 0
let g:ale_keep_list_window_open = 0
let g:ale_virtualtext_cursor    = 1
let g:ale_html_tidy_options     = '-config .tidyrc'
let g:ale_echo_msg_format       = '[%linter%] %s [%severity%]'
let g:ale_javascript_prettier_use_local_config = 1
autocmd MyAutoCmd ColorScheme * hi ALEVirtualTextWarning ctermfg=3 guifg=3
autocmd MyAutoCmd ColorScheme * hi ALEWarningSign ctermfg=3 guifg=3 ctermbg=0 guibg=0
autocmd MyAutoCmd ColorScheme * hi ALEVirtualTextError ctermfg=red guifg=red
autocmd MyAutoCmd ColorScheme * hi ALEErrorSign ctermfg=red guifg=red ctermbg=0 guibg=0
nnoremap <silent>]a :<C-u>ALENext<CR>
nnoremap <silent>[a :<C-u>ALEPrevious<CR>
'''

# php------------------------------------

[[plugins]]
repo = 'StanAngeloff/php.vim'
on_ft = ['html', 'php', 'phtml']

[[plugins]]
repo = 'lvht/phpcd.vim'
build = 'composer install'

[[plugins]]
repo = 'tysonandre/LanguageServer-phan-neovim'
build = 'composer update'
hook_add = '''
let g:phan_analyzed_directory   = '/mnt/d/workspace/new-hokushi/'
let g:phan_analyze_only_on_save = 1
let g:phan_enable_completion    = 1
let g:phan_additional_cli_flags = [
  \'--strict-type-checking',
  \'--plugin', 'InvokePHPNativeSyntaxCheckPlugin'
  \]
'''

[[plugins]]
repo = 'adoy/vim-php-refactoring-toolbox'
on_ft = ['php', 'phtml']
hook_add = '''
let g:vim_php_refactoring_use_default_mapping = 0
'''

[[plugins]]
repo = '2072/PHP-Indenting-for-VIm'
on_ft = ['php', 'phtml']

[[plugins]]
repo = 'captbaritone/better-indent-support-for-php-with-html'
on_ft = ['html', 'php', 'phtml']

# javascript & typescript----------------

[[plugins]]
repo = 'mhartington/nvim-typescript'
build = './install.sh'
on_event = 'VimEnter'

[[plugins]]
repo = 'HerringtonDarkholme/yats.vim'
on_ft = ['ts', 'javascript']

[[plugins]]
repo = 'burnettk/vim-angular'
on_ft = ['javascript']

# rust----------------------------------

[[plugins]]
repo = 'rust-lang/rust.vim'
on_ft = ['rust']
